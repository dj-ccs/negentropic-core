# v0.3.3-alpha LoD and Cascading Simulation System

**Version:** v0.3.3-alpha
**Status:** Partial Implementation (Temporal Cascade âœ…, Spatial LoD ðŸš§)
**Last Updated:** 2025-11-16

## Purpose

This document specifies the complete mechanics of the multi-scale simulation engine in negentropic-core. It defines the conservative flux-transfer formulas for upscaling and downscaling (moisture, momentum, runoff), rules for handling nonlinearities, and the camera-driven hysteresis protocol for LoD grid refinement and coarsening.

---

## 1. Overview

### 1.1 Multi-Scale Challenge

**Problem:** Regenerative ecosystem dynamics span 6+ orders of magnitude in time/space:
- **Microscale:** Soil aggregation (hours, meters)
- **Mesoscale:** Catchment hydrology (days, kilometers)
- **Macroscale:** Biotic pump (decades, continents)

**Solution:** Cascading simulation architecture
- **Temporal cascade:** Fast physics (hydrology) runs more frequently than slow physics (regeneration)
- **Spatial LoD:** Adaptive grid refinement based on camera position and feature importance

### 1.2 Design Principles

1. **Conservative Transfers:** Mass/momentum/energy conserved across scale transitions
2. **Deterministic:** Same inputs â†’ identical outputs (no Monte Carlo)
3. **Smooth Transitions:** Hysteresis prevents flickering during refinement/coarsening
4. **Bounded Complexity:** O(N log N) max, not O(NÂ²)

---

## 2. Temporal Cascading

### 2.1 Timescale Hierarchy

| Solver | Timestep | Call Frequency | Rationale |
|--------|----------|----------------|-----------|
| HYD-RLv1 | 1 hour | Every frame (10 Hz) | Fast infiltration dynamics |
| REGv1 | ~5.3 days | Every 128 HYD steps | Slow vegetation growth |
| REGv2 | ~5.3 days | Every 128 HYD steps | Microbial equilibration |
| ATMv1 | 10 seconds | Every frame | Atmospheric advection |
| Cloud Particles | 1 second | Every frame | Lagrangian advection |

**Performance Gain:** ~99.2% reduction in REG solver calls (128Ã— less frequent)

### 2.2 Implementation

**Master Timestepping Loop:**

```c
typedef struct {
    uint64_t hyd_step_count;
    uint64_t total_sim_time_s;
} SimulationClock;

void neg_step(SimulationState* state, float dt_seconds) {
    SimulationClock* clock = &state->clock;

    // Fast physics: Hydrology (every frame)
    richards_lite_step(state->grid, dt_seconds);

    // Increment counter
    clock->hyd_step_count++;
    clock->total_sim_time_s += (uint64_t)dt_seconds;

    // Slow physics: Regeneration (every 128 steps)
    if (clock->hyd_step_count % 128 == 0) {
        float dt_years = 128.0f * dt_seconds / (365.25f * 86400.0f);  // Convert to years
        regeneration_cascade_step(state->grid, dt_years);
        regeneration_microbial_step(state->grid, dt_years);
    }

    // Medium physics: Atmosphere (every frame, but 10s timestep)
    atmosphere_step(state->atm, 10.0f);

    // Lagrangian particles: Clouds (every frame, 1s timestep)
    for (int i = 0; i < state->cloud->num_particles; i++) {
        integrate_cloud_particle_rk4(&state->cloud->particles[i], state->atm, 1.0f);
    }
}
```

### 2.3 Accumulation Buffers

**Problem:** Slow solvers need accumulated fast-scale inputs.

**Example:** Regeneration needs average soil moisture over 5.3 days, not instantaneous.

**Solution:** Running average accumulator

```c
typedef struct {
    float* theta_accumulated;   // Sum of Î¸ over last 128 steps
    float* runoff_accumulated;  // Sum of runoff
    uint32_t accumulator_count; // Steps since last REG call
} AccumulationBuffers;

void accumulate_hydrology_outputs(AccumulationBuffers* buf, GridState* grid) {
    for (int i = 0; i < grid->size; i++) {
        buf->theta_accumulated[i] += grid->theta[i];
        buf->runoff_accumulated[i] += grid->runoff[i];
    }
    buf->accumulator_count++;
}

void consume_accumulation_buffers(AccumulationBuffers* buf, GridState* grid) {
    for (int i = 0; i < grid->size; i++) {
        grid->theta_avg[i] = buf->theta_accumulated[i] / buf->accumulator_count;
        grid->runoff_total[i] = buf->runoff_accumulated[i];  // Sum, not average

        // Reset
        buf->theta_accumulated[i] = 0.0f;
        buf->runoff_accumulated[i] = 0.0f;
    }
    buf->accumulator_count = 0;
}
```

---

## 3. Spatial Level-of-Detail (LoD)

### 3.1 Quad-Tree Grid Hierarchy

**Structure:**

```
Level 0 (coarsest): 16Ã—16 grid   (256 cells, 100 km spacing)
Level 1:            32Ã—32 grid   (1024 cells, 50 km spacing)
Level 2:            64Ã—64 grid   (4096 cells, 25 km spacing)
Level 3 (finest):   128Ã—128 grid (16384 cells, 12.5 km spacing)
```

**Storage:**

```c
typedef struct {
    GridState* grids[MAX_LOD_LEVELS];  // One grid per level
    uint32_t active_level;             // Current active level (0-3)
    uint32_t num_levels;
} LoD_Hierarchy;
```

### 3.2 Camera-Driven Refinement

**Criteria:**

Refine grid cell if:
1. **Distance to camera** < `threshold_distance`
2. **Feature importance** > `threshold_importance`

**Feature Importance:**

```
I(cell) = |âˆ‡Î¸| + |âˆ‡V| + |âˆ‡SOM| + Î± Â· runoff
```

Where:
- `|âˆ‡Î¸|`: Moisture gradient (wetter = more important)
- `|âˆ‡V|`: Vegetation gradient (edge of forest = important)
- `|âˆ‡SOM|`: SOM gradient (degraded/regenerative boundary)
- `Î± = 0.1`: Runoff weight (flowing water = important)

**Implementation:**

```c
bool should_refine_cell(GridState* grid, int i, int j, float cam_dist, float threshold_dist) {
    if (cam_dist > threshold_dist) return false;

    // Compute gradients (central differences)
    float grad_theta = compute_gradient_magnitude(grid->theta, i, j);
    float grad_veg = compute_gradient_magnitude(grid->vegetation, i, j);
    float grad_som = compute_gradient_magnitude(grid->som, i, j);
    float runoff_importance = 0.1f * grid->runoff[i][j];

    float importance = grad_theta + grad_veg + grad_som + runoff_importance;

    return importance > 0.5f;  // Threshold
}
```

### 3.3 Hysteresis Protocol

**Problem:** Camera moving near threshold causes flickering (rapid refine/coarsen).

**Solution:** Separate thresholds for refine vs. coarsen

```c
#define REFINE_DISTANCE_KM    50.0f
#define COARSEN_DISTANCE_KM   75.0f   // 50% larger (hysteresis margin)
#define REFINE_IMPORTANCE     0.5f
#define COARSEN_IMPORTANCE    0.3f    // 40% lower

bool should_refine(float dist, float importance) {
    return (dist < REFINE_DISTANCE_KM) && (importance > REFINE_IMPORTANCE);
}

bool should_coarsen(float dist, float importance) {
    return (dist > COARSEN_DISTANCE_KM) || (importance < COARSEN_IMPORTANCE);
}
```

**State Machine:**

```c
typedef enum {
    LOD_STATE_COARSE,
    LOD_STATE_REFINING,
    LOD_STATE_FINE,
    LOD_STATE_COARSENING
} LoD_State;

void update_lod_state(LoD_Cell* cell, float dist, float importance) {
    switch (cell->state) {
        case LOD_STATE_COARSE:
            if (should_refine(dist, importance)) {
                cell->state = LOD_STATE_REFINING;
            }
            break;

        case LOD_STATE_REFINING:
            // Transition complete (handled in refinement function)
            cell->state = LOD_STATE_FINE;
            break;

        case LOD_STATE_FINE:
            if (should_coarsen(dist, importance)) {
                cell->state = LOD_STATE_COARSENING;
            }
            break;

        case LOD_STATE_COARSENING:
            // Transition complete
            cell->state = LOD_STATE_COARSE;
            break;
    }
}
```

---

## 4. Conservative Flux Transfer

### 4.1 Upscaling (Fine â†’ Coarse)

**Mass Conservation:**

When coarsening 4 fine cells â†’ 1 coarse cell:

```
Î¸_coarse = (Î¸_0 + Î¸_1 + Î¸_2 + Î¸_3) / 4
```

**Momentum (Runoff) Conservation:**

```
runoff_coarse = Î£ runoff_i
                i=0..3
```

**Implementation:**

```c
void upscale_grid(GridState* fine, GridState* coarse) {
    int ratio = fine->grid_size / coarse->grid_size;  // e.g., 2 (2Ã—2 fine â†’ 1 coarse)

    for (int i = 0; i < coarse->grid_rows; i++) {
        for (int j = 0; j < coarse->grid_cols; j++) {
            float theta_sum = 0.0f;
            float runoff_sum = 0.0f;
            float veg_sum = 0.0f;

            // Aggregate from fine cells
            for (int di = 0; di < ratio; di++) {
                for (int dj = 0; dj < ratio; dj++) {
                    int fi = i * ratio + di;
                    int fj = j * ratio + dj;

                    theta_sum += fine->theta[fi][fj];
                    runoff_sum += fine->runoff[fi][fj];
                    veg_sum += fine->vegetation[fi][fj];
                }
            }

            // Average for intensive quantities
            coarse->theta[i][j] = theta_sum / (ratio * ratio);
            coarse->vegetation[i][j] = veg_sum / (ratio * ratio);

            // Sum for extensive quantities
            coarse->runoff[i][j] = runoff_sum;
        }
    }
}
```

### 4.2 Downscaling (Coarse â†’ Fine)

**Bilinear Interpolation (for smooth fields):**

```c
void downscale_grid_bilinear(GridState* coarse, GridState* fine) {
    int ratio = fine->grid_size / coarse->grid_size;

    for (int fi = 0; fi < fine->grid_rows; fi++) {
        for (int fj = 0; fj < fine->grid_cols; fj++) {
            // Map fine cell to coarse coordinates
            float ci_float = (float)fi / ratio;
            float cj_float = (float)fj / ratio;

            int ci0 = (int)floorf(ci_float);
            int cj0 = (int)floorf(cj_float);
            int ci1 = ci0 + 1;
            int cj1 = cj0 + 1;

            // Clamp
            ci0 = fmaxf(0, fminf(coarse->grid_rows - 1, ci0));
            ci1 = fmaxf(0, fminf(coarse->grid_rows - 1, ci1));
            cj0 = fmaxf(0, fminf(coarse->grid_cols - 1, cj0));
            cj1 = fmaxf(0, fminf(coarse->grid_cols - 1, cj1));

            // Weights
            float wi = ci_float - floorf(ci_float);
            float wj = cj_float - floorf(cj_float);

            // Bilinear
            float v00 = coarse->theta[ci0][cj0];
            float v01 = coarse->theta[ci0][cj1];
            float v10 = coarse->theta[ci1][cj0];
            float v11 = coarse->theta[ci1][cj1];

            fine->theta[fi][fj] = (1.0f - wi) * (1.0f - wj) * v00 +
                                  (1.0f - wi) * wj * v01 +
                                  wi * (1.0f - wj) * v10 +
                                  wi * wj * v11;
        }
    }
}
```

**Conservative Downscaling (for runoff):**

```c
void downscale_runoff_conservative(GridState* coarse, GridState* fine) {
    int ratio = fine->grid_size / coarse->grid_size;

    for (int i = 0; i < coarse->grid_rows; i++) {
        for (int j = 0; j < coarse->grid_cols; j++) {
            // Distribute coarse runoff equally to fine cells
            float runoff_per_cell = coarse->runoff[i][j] / (ratio * ratio);

            for (int di = 0; di < ratio; di++) {
                for (int dj = 0; dj < ratio; dj++) {
                    int fi = i * ratio + di;
                    int fj = j * ratio + dj;
                    fine->runoff[fi][fj] = runoff_per_cell;
                }
            }
        }
    }
}
```

### 4.3 Handling Nonlinearities

**Problem:** Averaging nonlinear functions introduces bias.

**Example:** Van Genuchten conductivity `K(Î¸)` is highly nonlinear.

**Bad:**
```c
K_coarse = K(Î¸_coarse)  // Wrong! Doesn't conserve flux
```

**Good:**
```c
// Average conductivity, not moisture
K_coarse = (K(Î¸_0) + K(Î¸_1) + K(Î¸_2) + K(Î¸_3)) / 4
```

**Implementation:**

```c
void upscale_conductivity(GridState* fine, GridState* coarse) {
    int ratio = fine->grid_size / coarse->grid_size;

    for (int i = 0; i < coarse->grid_rows; i++) {
        for (int j = 0; j < coarse->grid_cols; j++) {
            float K_sum = 0.0f;

            for (int di = 0; di < ratio; di++) {
                for (int dj = 0; dj < ratio; dj++) {
                    int fi = i * ratio + di;
                    int fj = j * ratio + dj;

                    // Compute conductivity at fine scale
                    float K_fine = get_hydraulic_conductivity(fine->theta[fi][fj]);
                    K_sum += K_fine;
                }
            }

            coarse->K_eff[i][j] = K_sum / (ratio * ratio);
        }
    }
}
```

---

## 5. Refinement Transition Protocol

### 5.1 Smooth Transition (Avoid Shocks)

**Problem:** Instantaneous refinement causes discontinuities in physics.

**Solution:** Blend old coarse data with new fine data over transition period.

```c
#define TRANSITION_FRAMES 30  // 3 seconds at 10 Hz

typedef struct {
    GridState* old_grid;        // Snapshot before refinement
    GridState* new_grid;        // Refined grid
    uint32_t transition_frame;  // 0 to TRANSITION_FRAMES
} TransitionState;

void blend_grids(TransitionState* trans) {
    float alpha = (float)trans->transition_frame / TRANSITION_FRAMES;

    for (int i = 0; i < trans->new_grid->size; i++) {
        // Blend moisture
        trans->new_grid->theta[i] = (1.0f - alpha) * trans->old_grid->theta[i] +
                                     alpha * trans->new_grid->theta[i];

        // Blend vegetation
        trans->new_grid->vegetation[i] = (1.0f - alpha) * trans->old_grid->vegetation[i] +
                                          alpha * trans->new_grid->vegetation[i];
    }

    trans->transition_frame++;
}
```

### 5.2 Refinement Workflow

**Steps:**
1. Identify cells to refine (camera distance + importance)
2. Allocate new fine grid (2Ã— resolution)
3. Downscale coarse data to fine grid (bilinear interpolation)
4. Snapshot old coarse grid for blending
5. Begin blend transition (30 frames)
6. After transition: deallocate old coarse grid

**Implementation:**

```c
void refine_cell(LoD_Hierarchy* lod, int level, int i, int j) {
    if (level >= lod->num_levels - 1) return;  // Already at finest

    GridState* coarse = lod->grids[level];
    GridState* fine = lod->grids[level + 1];

    // Downscale coarse â†’ fine
    downscale_grid_bilinear(coarse, fine);

    // Create transition state
    TransitionState* trans = malloc(sizeof(TransitionState));
    trans->old_grid = clone_grid(coarse);  // Snapshot
    trans->new_grid = fine;
    trans->transition_frame = 0;

    // Store transition (processed each frame)
    register_transition(lod, trans);

    // Activate finer level
    lod->active_level = level + 1;
}
```

---

## 6. Coarsening Protocol

### 6.1 Aggregate Statistics

**Problem:** Discarding fine-scale data loses information.

**Solution:** Store summary statistics in coarse cell.

```c
typedef struct {
    float mean;
    float variance;
    float min;
    float max;
} CellStatistics;

void compute_cell_statistics(GridState* fine, int i_coarse, int j_coarse, CellStatistics* stats) {
    int ratio = 2;  // 2Ã—2 fine â†’ 1 coarse
    float sum = 0.0f;
    float sum_sq = 0.0f;
    float min_val = 1e10f;
    float max_val = -1e10f;

    for (int di = 0; di < ratio; di++) {
        for (int dj = 0; dj < ratio; dj++) {
            int fi = i_coarse * ratio + di;
            int fj = j_coarse * ratio + dj;
            float val = fine->theta[fi][fj];

            sum += val;
            sum_sq += val * val;
            min_val = fminf(min_val, val);
            max_val = fmaxf(max_val, val);
        }
    }

    int count = ratio * ratio;
    stats->mean = sum / count;
    stats->variance = (sum_sq / count) - (stats->mean * stats->mean);
    stats->min = min_val;
    stats->max = max_val;
}
```

### 6.2 Coarsening Workflow

**Steps:**
1. Identify cells to coarsen (camera moved away)
2. Upscale fine data to coarse grid (conservative averaging)
3. Compute and store statistics (mean, variance, min, max)
4. Begin blend transition (30 frames)
5. After transition: deallocate fine grid

---

## 7. Performance Characteristics

### 7.1 Complexity Analysis

**Without LoD:**
- Uniform fine grid: O(NÂ²) where N = 128 (16,384 cells)

**With LoD (3 levels active):**
- Level 0: 16Ã—16 = 256 cells
- Level 1: 32Ã—32 = 1,024 cells (20% of domain)
- Level 2: 64Ã—64 = 4,096 cells (10% of domain)
- **Total: ~1,500 cells** (~10Ã— reduction)

### 7.2 Benchmarks

| Operation | Cost (per cell) | Overhead |
|-----------|-----------------|----------|
| Upscaling | ~50 ns | Amortized over 128 frames |
| Downscaling | ~80 ns | Amortized over 128 frames |
| Blending | ~10 ns/frame | 30 frames |
| Importance calculation | ~20 ns | Every frame |

**Total LoD Overhead:** <5% of frame budget

---

## 8. Spatial Partitioning (T-BSP Trees)

### 8.1 Time-Bucketed Binary Space Partitioning

**Purpose:** Efficiently manage cell handoff between LoD levels.

**Structure:**

```c
typedef struct TBSP_Node {
    AABB bounds;                // Axis-aligned bounding box
    struct TBSP_Node* left;
    struct TBSP_Node* right;
    GridCell* cells;            // Leaf: list of cells
    uint32_t num_cells;
} TBSP_Node;
```

**Split Criterion:**

```c
bool should_split_node(TBSP_Node* node) {
    return node->num_cells > 64;  // Max 64 cells per leaf
}

void split_node(TBSP_Node* node) {
    // Choose longest axis
    float dx = node->bounds.max_x - node->bounds.min_x;
    float dy = node->bounds.max_y - node->bounds.min_y;
    float dz = node->bounds.max_z - node->bounds.min_z;

    int axis = (dx >= dy && dx >= dz) ? 0 : (dy >= dz) ? 1 : 2;
    float split_pos = (node->bounds.min[axis] + node->bounds.max[axis]) / 2.0f;

    // Partition cells
    node->left = create_node();
    node->right = create_node();

    for (int i = 0; i < node->num_cells; i++) {
        if (node->cells[i].position[axis] < split_pos) {
            add_cell_to_node(node->left, &node->cells[i]);
        } else {
            add_cell_to_node(node->right, &node->cells[i]);
        }
    }

    free(node->cells);  // No longer a leaf
    node->cells = NULL;
}
```

### 8.2 Frustum Culling

**Skip cells outside camera frustum:**

```c
bool is_cell_in_frustum(GridCell* cell, Frustum* frustum) {
    // Test cell AABB against 6 frustum planes
    for (int i = 0; i < 6; i++) {
        float dist = dot(frustum->planes[i].normal, cell->center) + frustum->planes[i].d;
        if (dist < -cell->radius) {
            return false;  // Cell completely outside
        }
    }
    return true;
}
```

---

## 9. Future Extensions

### 9.1 Wavelet-Based Compression

**Compress coarse-level grids:**

```c
// Haar wavelet transform (1D)
void haar_transform(float* data, int n) {
    float* temp = malloc(n * sizeof(float));

    while (n > 1) {
        for (int i = 0; i < n / 2; i++) {
            temp[i] = (data[2 * i] + data[2 * i + 1]) / sqrtf(2.0f);         // Average
            temp[n / 2 + i] = (data[2 * i] - data[2 * i + 1]) / sqrtf(2.0f); // Detail
        }
        memcpy(data, temp, n * sizeof(float));
        n /= 2;
    }

    free(temp);
}
```

**Threshold small detail coefficients â†’ Sparse storage**

### 9.2 GPU-Accelerated Upscaling/Downscaling

**Compute shader for bilinear interpolation:**

```glsl
#version 430

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) buffer CoarseGrid {
    float coarse[];
};

layout(binding = 1) buffer FineGrid {
    float fine[];
};

uniform int ratio;

void main() {
    ivec2 fine_idx = ivec2(gl_GlobalInvocationID.xy);
    vec2 coarse_idx_float = vec2(fine_idx) / float(ratio);

    // Bilinear interpolation (omitted for brevity)
    fine[fine_idx.y * grid_width + fine_idx.x] = sample_bilinear(coarse, coarse_idx_float);
}
```

---

## 10. Validation

### 10.1 Mass Conservation Test

**Invariant:** Total moisture before and after refinement/coarsening must match.

```c
void test_mass_conservation() {
    GridState* coarse = create_test_grid(32, 32);
    GridState* fine = create_test_grid(64, 64);

    // Fill coarse grid with random data
    fill_random(coarse->theta, coarse->size);

    // Downscale
    downscale_grid_bilinear(coarse, fine);

    // Upscale back
    GridState* coarse_reconstructed = create_test_grid(32, 32);
    upscale_grid(fine, coarse_reconstructed);

    // Verify total mass
    float mass_original = sum_array(coarse->theta, coarse->size);
    float mass_reconstructed = sum_array(coarse_reconstructed->theta, coarse_reconstructed->size);

    assert(fabsf(mass_original - mass_reconstructed) < 1e-6f);
}
```

### 10.2 Hysteresis Test

**Invariant:** Camera oscillating near threshold should not cause frequent refinement/coarsening.

```c
void test_hysteresis() {
    float camera_distance = 52.0f;  // Near REFINE_DISTANCE (50 km)

    LoD_State state = LOD_STATE_COARSE;

    for (int i = 0; i < 100; i++) {
        // Oscillate distance Â±2 km
        camera_distance = 52.0f + 2.0f * sinf(i * 0.1f);

        // Update state
        update_lod_state_with_hysteresis(&state, camera_distance, 0.6f);
    }

    // State should remain stable (not flicker between COARSE and FINE)
    assert(state == LOD_STATE_COARSE || state == LOD_STATE_FINE);
}
```

---

## 11. References

1. **Temporal Operator Splitting:** Yanenko, N.N. "The Method of Fractional Steps" (1971)
2. **Conservative Remapping:** Jones, P.W. "Conservative remapping between unstructured grids" (1999)
3. **Quad-Tree LoD:** Losasso et al., "Simulating water and smoke with an octree data structure" (2004)
4. **T-BSP Trees:** Samet, H. "The Design and Analysis of Spatial Data Structures" (1990)
5. **Wavelet Compression:** Stollnitz et al., "Wavelets for Computer Graphics" (1995)

---

**Document Control:**
- **Approved by:** Technical Lead
- **Status:** Partial (temporal âœ…, spatial ðŸš§)
- **Review Frequency:** Every release
- **Next Review:** v0.4.0-alpha
