# v0.3.3-alpha Atmospheric and Cloud System

**Version:** v0.3.3-alpha
**Status:** Planned (Stub Implementation)
**Last Updated:** 2025-11-16

## Purpose

This document defines the visual and physical coupling of the dynamic cloud layer in negentropic-core. It specifies the advection ODE for cloud particle movement, the GLSL shader layout for the custom deck.gl layer, noise domain warping, and coupling rules between cloud moisture and atmospheric humidity fields.

---

## 1. Overview

### 1.1 Dual-Layer Architecture

**Layer 1: Core Atmospheric State (Grid-Based)**
- Temperature (θ)
- Humidity (q)
- Pressure (p)
- Wind velocity (u, v)

**Layer 2: Cloud Particles (Lagrangian)**
- Position (x, y, z)
- Moisture content (m)
- Lifetime (τ)
- Rendered via deck.gl custom layer

### 1.2 Coupling Strategy

**Atmospheric → Clouds:**
- Wind advects cloud particles
- Humidity converts to cloud moisture (condensation)

**Clouds → Atmospheric:**
- Precipitation removes cloud moisture
- Shading modifies surface temperature

---

## 2. Cloud Particle Advection ODE

### 2.1 Governing Equation

**Position Evolution:**

```
dx/dt = u(x, y, z, t) + w_turb(x, y, z, t)
dy/dt = v(x, y, z, t) + w_turb(x, y, z, t)
dz/dt = w_c(x, y, t) + w_buoyancy(m, T)
```

**Where:**
- `u, v`: Horizontal wind components (from atmospheric solver)
- `w_c`: Vertical pseudo-velocity (from torsion module)
- `w_turb`: Turbulent wind noise (domain-warped Perlin noise)
- `w_buoyancy`: Buoyant rise due to moisture content

### 2.2 Moisture Evolution

**Cloud Moisture ODE:**

```
dm/dt = γ_cond · max(q - q_sat, 0) - γ_evap · m - γ_precip · m²
```

**Parameters:**
- `γ_cond = 0.1 s⁻¹`: Condensation rate
- `γ_evap = 0.05 s⁻¹`: Evaporation rate
- `γ_precip = 0.02`: Precipitation coefficient (quadratic in m)
- `q_sat = 0.622 · e_sat / (p - e_sat)`: Saturation humidity (Clausius-Clapeyron)

**Saturation Vapor Pressure (e_sat):**

```
e_sat(T) = 611 · exp[17.27 · (T - 273) / (T - 36)]  [Pa]
```

### 2.3 Lifetime Tracking

**Cloud Particle Age:**

```
dτ/dt = 1
```

**Death Condition:**
- If `m < m_min` (moisture depleted): Remove particle
- If `τ > τ_max` (too old): Remove particle
- If `z < z_ground` (hit ground): Convert to precipitation, remove

**Thresholds:**
- `m_min = 0.01 g/kg`
- `τ_max = 3600 s` (1 hour)

---

## 3. Discrete Integration Scheme

### 3.1 RK4 Integration

**Motivation:** Fourth-order Runge-Kutta for smooth particle trajectories.

**Pseudocode:**

```c
typedef struct {
    float x, y, z;      // Position (meters)
    float m;            // Moisture content (g/kg)
    float tau;          // Lifetime (seconds)
    uint32_t id;        // Unique particle ID
} CloudParticle;

void integrate_cloud_particle_rk4(CloudParticle* p, AtmosphericState* atm, float dt) {
    // k1
    float u1 = sample_wind_u(atm, p->x, p->y, p->z);
    float v1 = sample_wind_v(atm, p->x, p->y, p->z);
    float w1 = sample_vertical_velocity(atm, p->x, p->y) + compute_buoyancy(p->m, atm->T);
    float dm1 = compute_moisture_rate(p->m, atm->q, atm->T, atm->p);

    // k2 (midpoint with k1)
    float x2 = p->x + 0.5f * dt * u1;
    float y2 = p->y + 0.5f * dt * v1;
    float z2 = p->z + 0.5f * dt * w1;
    float m2 = p->m + 0.5f * dt * dm1;

    float u2 = sample_wind_u(atm, x2, y2, z2);
    float v2 = sample_wind_v(atm, x2, y2, z2);
    float w2 = sample_vertical_velocity(atm, x2, y2) + compute_buoyancy(m2, atm->T);
    float dm2 = compute_moisture_rate(m2, atm->q, atm->T, atm->p);

    // k3 (midpoint with k2)
    float x3 = p->x + 0.5f * dt * u2;
    float y3 = p->y + 0.5f * dt * v2;
    float z3 = p->z + 0.5f * dt * w2;
    float m3 = p->m + 0.5f * dt * dm2;

    float u3 = sample_wind_u(atm, x3, y3, z3);
    float v3 = sample_wind_v(atm, x3, y3, z3);
    float w3 = sample_vertical_velocity(atm, x3, y3) + compute_buoyancy(m3, atm->T);
    float dm3 = compute_moisture_rate(m3, atm->q, atm->T, atm->p);

    // k4 (endpoint with k3)
    float x4 = p->x + dt * u3;
    float y4 = p->y + dt * v3;
    float z4 = p->z + dt * w3;
    float m4 = p->m + dt * dm3;

    float u4 = sample_wind_u(atm, x4, y4, z4);
    float v4 = sample_wind_v(atm, x4, y4, z4);
    float w4 = sample_vertical_velocity(atm, x4, y4) + compute_buoyancy(m4, atm->T);
    float dm4 = compute_moisture_rate(m4, atm->q, atm->T, atm->p);

    // Combine (weighted average)
    p->x += dt / 6.0f * (u1 + 2.0f*u2 + 2.0f*u3 + u4);
    p->y += dt / 6.0f * (v1 + 2.0f*v2 + 2.0f*v3 + v4);
    p->z += dt / 6.0f * (w1 + 2.0f*w2 + 2.0f*w3 + w4);
    p->m += dt / 6.0f * (dm1 + 2.0f*dm2 + 2.0f*dm3 + dm4);
    p->tau += dt;
}
```

### 3.2 Velocity Sampling (Bilinear Interpolation)

```c
float sample_wind_u(AtmosphericState* atm, float x, float y, float z) {
    // Convert world coordinates to grid indices
    float i_float = (x - atm->x_min) / atm->dx;
    float j_float = (y - atm->y_min) / atm->dy;

    int i0 = (int)floorf(i_float);
    int j0 = (int)floorf(j_float);
    int i1 = i0 + 1;
    int j1 = j0 + 1;

    // Clamp to grid bounds
    i0 = fmaxf(0, fminf(atm->grid_rows - 1, i0));
    i1 = fmaxf(0, fminf(atm->grid_rows - 1, i1));
    j0 = fmaxf(0, fminf(atm->grid_cols - 1, j0));
    j1 = fmaxf(0, fminf(atm->grid_cols - 1, j1));

    // Bilinear weights
    float wx = i_float - floorf(i_float);
    float wy = j_float - floorf(j_float);

    // Interpolate
    float u00 = atm->u_wind[i0][j0];
    float u01 = atm->u_wind[i0][j1];
    float u10 = atm->u_wind[i1][j0];
    float u11 = atm->u_wind[i1][j1];

    return (1.0f - wx) * (1.0f - wy) * u00 +
           (1.0f - wx) * wy * u01 +
           wx * (1.0f - wy) * u10 +
           wx * wy * u11;
}
```

---

## 4. Noise Domain Warping

### 4.1 Turbulent Wind Field

**Purpose:** Add realistic turbulence to cloud motion beyond gridded wind data.

**Multi-Octave Perlin Noise:**

```
w_turb(x, y, z, t) = Σ [A_i · P(f_i · r + φ_i(t))]
                     i=0..N
```

**Where:**
- `P(r)`: 3D Perlin noise function
- `A_i = A_0 / 2^i`: Amplitude (halves per octave)
- `f_i = f_0 · 2^i`: Frequency (doubles per octave)
- `φ_i(t) = ω_i · t`: Time-varying phase shift
- `N = 4`: Number of octaves

**Parameters:**
- `A_0 = 2.0 m/s`: Base turbulence amplitude
- `f_0 = 0.001 m⁻¹`: Base frequency (1 km wavelength)
- `ω_0 = 0.05 rad/s`: Base angular frequency

### 4.2 Domain Warping

**Motivation:** Break visual repetition patterns in Perlin noise.

**Warped Noise:**

```
P_warped(x, y, z) = P(x + q_x, y + q_y, z + q_z)

where:
  q_x = P(x + 0.1, y, z)
  q_y = P(x, y + 0.1, z)
  q_z = P(x, y, z + 0.1)
```

**Implementation:**

```c
float domain_warped_noise_3d(float x, float y, float z, NegRNG* rng) {
    // First-level offsets
    float qx = perlin_noise_3d(x + 0.1f, y, z);
    float qy = perlin_noise_3d(x, y + 0.1f, z);
    float qz = perlin_noise_3d(x, y, z + 0.1f);

    // Warped coordinates
    float x_warp = x + qx;
    float y_warp = y + qy;
    float z_warp = z + qz;

    // Final noise sample
    return perlin_noise_3d(x_warp, y_warp, z_warp);
}
```

### 4.3 Perlin Noise Implementation

**Gradient Lattice (256 entries):**

```c
#define PERLIN_TABLE_SIZE 256
static float grad3[PERLIN_TABLE_SIZE][3];
static uint8_t perm[PERLIN_TABLE_SIZE * 2];

void init_perlin_noise(NegRNG* rng) {
    // Generate random gradient vectors
    for (int i = 0; i < PERLIN_TABLE_SIZE; i++) {
        float theta = neg_rng_uniform(rng) * 2.0f * M_PI;
        float phi = acosf(2.0f * neg_rng_uniform(rng) - 1.0f);

        grad3[i][0] = sinf(phi) * cosf(theta);
        grad3[i][1] = sinf(phi) * sinf(theta);
        grad3[i][2] = cosf(phi);
    }

    // Permutation table
    for (int i = 0; i < PERLIN_TABLE_SIZE; i++) {
        perm[i] = i;
    }
    // Shuffle
    for (int i = PERLIN_TABLE_SIZE - 1; i > 0; i--) {
        int j = neg_rng_uniform_int(rng, i + 1);
        uint8_t tmp = perm[i];
        perm[i] = perm[j];
        perm[j] = tmp;
    }
    // Duplicate for wrapping
    for (int i = 0; i < PERLIN_TABLE_SIZE; i++) {
        perm[i + PERLIN_TABLE_SIZE] = perm[i];
    }
}

float perlin_noise_3d(float x, float y, float z) {
    int X = ((int)floorf(x)) & 255;
    int Y = ((int)floorf(y)) & 255;
    int Z = ((int)floorf(z)) & 255;

    x -= floorf(x);
    y -= floorf(y);
    z -= floorf(z);

    float u = fade(x);
    float v = fade(y);
    float w = fade(z);

    int A = perm[X] + Y;
    int AA = perm[A] + Z;
    int AB = perm[A + 1] + Z;
    int B = perm[X + 1] + Y;
    int BA = perm[B] + Z;
    int BB = perm[B + 1] + Z;

    return lerp(w,
        lerp(v, lerp(u, grad(perm[AA], x, y, z),
                        grad(perm[BA], x - 1, y, z)),
                lerp(u, grad(perm[AB], x, y - 1, z),
                        grad(perm[BB], x - 1, y - 1, z))),
        lerp(v, lerp(u, grad(perm[AA + 1], x, y, z - 1),
                        grad(perm[BA + 1], x - 1, y, z - 1)),
                lerp(u, grad(perm[AB + 1], x, y - 1, z - 1),
                        grad(perm[BB + 1], x - 1, y - 1, z - 1))));
}

float fade(float t) {
    return t * t * t * (t * (t * 6.0f - 15.0f) + 10.0f);
}

float grad(int hash, float x, float y, float z) {
    int h = hash & 255;
    return grad3[h][0] * x + grad3[h][1] * y + grad3[h][2] * z;
}

float lerp(float t, float a, float b) {
    return a + t * (b - a);
}
```

---

## 5. deck.gl Custom Cloud Layer

### 5.1 Layer Architecture

**deck.gl Layer Class:**

```javascript
import {Layer} from '@deck.gl/core';
import {Model, Geometry} from '@luma.gl/engine';

export class CloudParticleLayer extends Layer {
  static layerName = 'CloudParticleLayer';

  static defaultProps = {
    getPosition: {type: 'accessor', value: d => d.position},
    getMoisture: {type: 'accessor', value: d => d.moisture},
    getSize: {type: 'accessor', value: 10},
    opacity: {type: 'number', value: 0.8}
  };

  getShaders() {
    return {
      vs: cloudVertexShader,
      fs: cloudFragmentShader,
      modules: ['project32', 'picking']
    };
  }

  initializeState() {
    const {gl} = this.context;

    // Billboard geometry (two triangles)
    const geometry = new Geometry({
      drawMode: gl.TRIANGLES,
      attributes: {
        positions: new Float32Array([
          -1, -1, 0,
           1, -1, 0,
           1,  1, 0,
          -1, -1, 0,
           1,  1, 0,
          -1,  1, 0
        ])
      }
    });

    this.setState({
      model: new Model(gl, {
        ...this.getShaders(),
        geometry,
        isInstanced: true
      })
    });
  }

  draw({uniforms}) {
    const {opacity} = this.props;
    this.state.model.setUniforms({...uniforms, opacity}).draw();
  }
}
```

### 5.2 Vertex Shader (GLSL)

```glsl
#version 300 es

// Attributes
in vec3 positions;          // Billboard quad vertices
in vec3 instancePositions;  // Cloud particle positions (ECEF)
in float instanceMoisture;  // Moisture content (g/kg)
in float instanceAge;       // Lifetime (seconds)

// Uniforms
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform float opacity;
uniform float particleSize;

// Outputs
out float vMoisture;
out float vAge;

void main() {
  // Billboard (always face camera)
  vec3 cameraRight = vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]);
  vec3 cameraUp = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);

  vec3 billboardPos = instancePositions +
                      cameraRight * positions.x * particleSize +
                      cameraUp * positions.y * particleSize;

  gl_Position = projectionMatrix * viewMatrix * vec4(billboardPos, 1.0);

  vMoisture = instanceMoisture;
  vAge = instanceAge;
}
```

### 5.3 Fragment Shader (GLSL)

```glsl
#version 300 es
precision highp float;

// Inputs
in float vMoisture;
in float vAge;

// Uniforms
uniform float opacity;

// Output
out vec4 fragColor;

// Perlin-like noise function (simplified)
float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);  // Smoothstep

    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));

    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

void main() {
  // Radial falloff (soft sphere)
  vec2 coord = gl_PointCoord * 2.0 - 1.0;
  float dist = length(coord);
  if (dist > 1.0) discard;  // Circular clip

  float falloff = 1.0 - smoothstep(0.5, 1.0, dist);

  // Moisture-based color (dark gray → white)
  float brightness = 0.3 + 0.7 * clamp(vMoisture / 5.0, 0.0, 1.0);
  vec3 cloudColor = vec3(brightness);

  // Add noise texture
  float noiseVal = noise(coord * 8.0 + vec2(vAge * 0.1));
  cloudColor += vec3(noiseVal * 0.1);

  // Age-based alpha fade
  float ageFade = 1.0 - clamp(vAge / 3600.0, 0.0, 1.0);  // Fade over 1 hour

  fragColor = vec4(cloudColor, falloff * opacity * ageFade);
}
```

---

## 6. Coupling with Atmospheric Humidity

### 6.1 Condensation (Atmospheric → Clouds)

**Per Grid Cell:**

```c
float condensation_rate = 0.1f * fmaxf(0.0f, atm->humidity[i][j] - q_sat);

// Reduce atmospheric humidity
atm->humidity[i][j] -= condensation_rate * dt;

// Spawn new cloud particles
int num_new_particles = (int)(condensation_rate * 100.0f);  // Heuristic
for (int n = 0; n < num_new_particles; n++) {
    CloudParticle p;
    p.x = grid_x[i][j] + neg_rng_uniform(&rng) * dx;
    p.y = grid_y[i][j] + neg_rng_uniform(&rng) * dy;
    p.z = 1000.0f;  // Start at 1 km altitude
    p.m = condensation_rate / num_new_particles;
    p.tau = 0.0f;
    add_cloud_particle(&cloud_state, p);
}
```

### 6.2 Evaporation (Clouds → Atmospheric)

**Redistribute Moisture Back to Grid:**

```c
for (int p = 0; p < cloud_state->num_particles; p++) {
    CloudParticle* particle = &cloud_state->particles[p];

    // Compute evaporation
    float evap_rate = 0.05f * particle->m;  // 5% per second

    // Find grid cell containing particle
    int i = (int)((particle->x - atm->x_min) / atm->dx);
    int j = (int)((particle->y - atm->y_min) / atm->dy);

    if (i >= 0 && i < atm->grid_rows && j >= 0 && j < atm->grid_cols) {
        atm->humidity[i][j] += evap_rate * dt;
    }

    // Reduce particle moisture
    particle->m -= evap_rate * dt;

    // Remove if depleted
    if (particle->m < 0.01f) {
        remove_cloud_particle(&cloud_state, p);
        p--;  // Adjust index after removal
    }
}
```

### 6.3 Precipitation (Clouds → Surface)

**Quadratic Autoconversion:**

```c
for (int p = 0; p < cloud_state->num_particles; p++) {
    CloudParticle* particle = &cloud_state->particles[p];

    // Precipitation rate (quadratic in moisture)
    float precip_rate = 0.02f * particle->m * particle->m;

    // Find surface grid cell
    int i = (int)((particle->x - atm->x_min) / atm->dx);
    int j = (int)((particle->y - atm->y_min) / atm->dy);

    if (i >= 0 && i < atm->grid_rows && j >= 0 && j < atm->grid_cols) {
        atm->precipitation[i][j] += precip_rate * dt;  // mm/hr
    }

    // Reduce moisture
    particle->m -= precip_rate * dt;

    // Remove if on ground
    if (particle->z < atm->elevation[i][j]) {
        remove_cloud_particle(&cloud_state, p);
        p--;
    }
}
```

---

## 7. Biotic Pump Coupling (Optional)

### 7.1 Enhanced Condensation Over Vegetation

**Vegetation-Driven Moisture Convergence:**

```
γ_cond_eff = γ_cond · (1 + β_veg · V)
```

**Where:**
- `β_veg = 2.0`: Vegetation multiplier (Makarieva & Gorshkov)
- `V`: Vegetation cover fraction (from REG solver)

**Implementation:**

```c
float enhanced_condensation_rate(float humidity, float q_sat, float vegetation) {
    float base_rate = 0.1f * fmaxf(0.0f, humidity - q_sat);
    float veg_multiplier = 1.0f + 2.0f * vegetation;
    return base_rate * veg_multiplier;
}
```

### 7.2 Forest Continuity Thresholds

**Critical Vegetation Threshold:**

If `V > 0.6` over contiguous area > 100 km²:
- Activate biotic pump (enhanced moisture convergence)
- Increase cloud formation rate by 3×

**Spatial Integration:**

```c
bool check_forest_continuity(GridState* grid, int i, int j, float threshold) {
    // Breadth-first search for connected vegetation
    int visited[grid->rows][grid->cols] = {0};
    Queue queue = queue_create();
    queue_push(&queue, (Point){i, j});

    int area_count = 0;
    while (!queue_is_empty(&queue)) {
        Point p = queue_pop(&queue);
        if (visited[p.i][p.j]) continue;
        visited[p.i][p.j] = 1;

        if (grid->vegetation[p.i][p.j] > threshold) {
            area_count++;

            // Add neighbors
            for (int d = 0; d < 4; d++) {  // 4-connected
                int ni = p.i + DX[d];
                int nj = p.j + DY[d];
                if (ni >= 0 && ni < grid->rows && nj >= 0 && nj < grid->cols) {
                    queue_push(&queue, (Point){ni, nj});
                }
            }
        }
    }

    queue_destroy(&queue);
    float area_km2 = area_count * grid->dx * grid->dy / 1e6;
    return area_km2 > 100.0f;
}
```

---

## 8. Performance Targets

| Operation | Target | Current Status |
|-----------|--------|----------------|
| Particle integration (RK4) | <200 ns/particle | TBD |
| Noise sampling | <50 ns/sample | TBD |
| Grid coupling | <10 ns/particle | TBD |
| deck.gl rendering | 60 FPS @ 100k particles | TBD |
| Total overhead | <20% of frame budget | TBD |

**Optimization Strategies:**
- Spatial partitioning (octree) for particle-grid coupling
- GPU-accelerated noise generation (compute shaders)
- Particle pooling (reuse dead particles)

---

## 9. Data Structures

### 9.1 Cloud State

```c
typedef struct {
    CloudParticle* particles;   // Dynamic array
    uint32_t num_particles;
    uint32_t capacity;
    NegRNG rng;                 // For turbulence noise
} CloudState;
```

### 9.2 Initialization

```c
CloudState* cloud_state_create(uint32_t initial_capacity) {
    CloudState* state = malloc(sizeof(CloudState));
    state->particles = malloc(initial_capacity * sizeof(CloudParticle));
    state->num_particles = 0;
    state->capacity = initial_capacity;
    neg_rng_init(&state->rng, 0x123456789ABCDEF);
    init_perlin_noise(&state->rng);
    return state;
}
```

---

## 10. Validation

### 10.1 Test Cases

1. **Static Atmosphere:** Particles should settle (no wind)
2. **Uniform Wind:** Particles advect at constant velocity
3. **Vortex:** Particles spiral around low-pressure center
4. **Condensation-Evaporation Equilibrium:** Mass conserved

### 10.2 Visual Quality Metrics

- **Spatial Coverage:** Clouds should cover 20-40% of humid regions
- **Temporal Coherence:** No sudden pops/disappearances (smooth fade)
- **Realism:** Wispy tendrils, billowing shapes (domain warping effective)

---

## 11. References

1. **Clausius-Clapeyron:** Bolton, D. "The computation of equivalent potential temperature" (1980)
2. **Biotic Pump:** Makarieva & Gorshkov, "Biotic pump of atmospheric moisture" (2007)
3. **Domain Warping:** Quilez, I. "Warp noise" (2014) https://iquilezles.org/articles/warp/
4. **Perlin Noise:** Perlin, K. "Improving noise" (2002)
5. **Cloud Microphysics:** Pruppacher & Klett, "Microphysics of Clouds and Precipitation" (2010)

---

**Document Control:**
- **Approved by:** Technical Lead
- **Status:** Planned (awaiting ATMv1 + deck.gl integration)
- **Review Frequency:** Every release
- **Next Review:** v0.4.0-alpha
