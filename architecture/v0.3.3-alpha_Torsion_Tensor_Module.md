# v0.3.3-alpha Torsion Tensor Module

**Version:** v0.3.3-alpha
**Status:** Planned (Stub Implementation)
**Last Updated:** 2025-11-16

## Purpose

This document specifies the complete physics and implementation of the "2.5D" vorticity simulation module. It defines the discrete curl operator for cubed-sphere grids, computation of vertical pseudo-velocity (`w_c`), and feedback mechanisms into buoyancy and convection terms in the atmospheric solver.

---

## 1. Overview

### 1.1 Motivation

**Problem:** Traditional 2D atmospheric models cannot capture rotational dynamics (vorticity, eddies, cyclones) which are critical for:
- Accurate precipitation patterns
- Energy dissipation in turbulent flows
- Realistic cloud formation and movement

**Solution:** "2.5D" Torsion Tensor Module
- Horizontal vorticity field (ω_z) computed from horizontal velocity
- Vertical pseudo-velocity (w_c) inferred from vorticity (no full 3D solve)
- Feedback into buoyancy and convection terms

### 1.2 Physical Basis

**Vorticity (ω):** Curl of velocity field

```
ω = ∇ × u
```

For 2D horizontal flow `u = (u_x, u_y, 0)`:

```
ω_z = ∂u_y/∂x - ∂u_x/∂y
```

**Vertical Pseudo-Velocity (w_c):**

Approximation based on vorticity stretching:

```
w_c ≈ -H · ∇²ω_z
```

Where `H` is characteristic atmospheric height (~1 km).

---

## 2. Discrete Curl Operator for Cubed-Sphere Grid

### 2.1 Grid Structure

**Cubed-Sphere Topology:**
- Six cube faces (±X, ±Y, ±Z)
- Each face has NxN grid cells
- Local (u, v) coordinates per face

**Velocity Components:**
- `u_u`: Velocity in local u-direction
- `u_v`: Velocity in local v-direction

### 2.2 Finite Difference Curl

**Central Differences:**

```
(∂u_v/∂u)_ij ≈ (u_v[i+1][j] - u_v[i-1][j]) / (2·Δu)
(∂u_u/∂v)_ij ≈ (u_u[i][j+1] - u_u[i][j-1]) / (2·Δv)
```

**Vorticity:**

```
ω_z[i][j] = (∂u_v/∂u)_ij - (∂u_u/∂v)_ij
```

### 2.3 Implementation

```c
typedef struct {
    float u_u;  // Velocity in u-direction (m/s)
    float u_v;  // Velocity in v-direction (m/s)
} Velocity2D;

float compute_vorticity_cubed_sphere(Velocity2D** velocity, int i, int j, float du, float dv) {
    // Boundary check
    if (i <= 0 || i >= grid_size - 1 || j <= 0 || j >= grid_size - 1) {
        return 0.0f;  // Zero vorticity at boundaries
    }

    // Central differences
    float du_v_du = (velocity[i+1][j].u_v - velocity[i-1][j].u_v) / (2.0f * du);
    float du_u_dv = (velocity[i][j+1].u_u - velocity[i][j-1].u_u) / (2.0f * dv);

    return du_v_du - du_u_dv;
}
```

### 2.4 Cubed-Sphere Edge Handling

**Problem:** Velocity components are discontinuous across cube face edges.

**Solution:** Transform velocity to common frame before differencing.

```c
float compute_vorticity_at_edge(int face_id, Velocity2D** velocity, int i, int j, float du, float dv) {
    // If on edge, transform neighbor velocity to local frame
    if (i == 0) {
        // Left edge: fetch from adjacent face
        int neighbor_face, neighbor_i, neighbor_j;
        get_left_neighbor(face_id, i, j, &neighbor_face, &neighbor_i, &neighbor_j);

        Velocity2D neighbor_vel = velocity_on_face[neighbor_face][neighbor_i][neighbor_j];
        Velocity2D transformed_vel = transform_velocity_to_local_frame(neighbor_face, face_id, neighbor_vel);

        // Use transformed velocity in finite difference
        float du_v_du = (velocity[i+1][j].u_v - transformed_vel.u_v) / (2.0f * du);
        float du_u_dv = (velocity[i][j+1].u_u - velocity[i][j-1].u_u) / (2.0f * dv);
        return du_v_du - du_u_dv;
    }

    // Similar logic for other edges...
    return compute_vorticity_cubed_sphere(velocity, i, j, du, dv);
}
```

**Transform Matrix (Example: +X face to +Y face):**

```c
Velocity2D transform_velocity_to_local_frame(int from_face, int to_face, Velocity2D vel) {
    // Rotation matrix between cube faces
    // (Simplified: full implementation requires quaternion rotations)

    if (from_face == 0 && to_face == 2) {  // +X → +Y
        return (Velocity2D){-vel.u_v, vel.u_u};  // 90° rotation
    }

    // ... other face pairs
    return vel;  // Identity if same face
}
```

---

## 3. Vertical Pseudo-Velocity (w_c)

### 3.1 Laplacian of Vorticity

**Discrete Laplacian:**

```
∇²ω_z[i][j] ≈ (ω_z[i+1][j] + ω_z[i-1][j] + ω_z[i][j+1] + ω_z[i][j-1] - 4·ω_z[i][j]) / (Δu²)
```

**Implementation:**

```c
float compute_laplacian_vorticity(float** vorticity, int i, int j, float du) {
    if (i <= 0 || i >= grid_size - 1 || j <= 0 || j >= grid_size - 1) {
        return 0.0f;
    }

    float laplacian = (vorticity[i+1][j] + vorticity[i-1][j] +
                       vorticity[i][j+1] + vorticity[i][j-1] -
                       4.0f * vorticity[i][j]) / (du * du);
    return laplacian;
}
```

### 3.2 Vertical Velocity Approximation

**Formula:**

```
w_c[i][j] = -H · ∇²ω_z[i][j]
```

**Parameters:**
- `H = 1000 m`: Characteristic atmospheric height (1 km)

**Implementation:**

```c
float compute_vertical_pseudo_velocity(float** vorticity, int i, int j, float du, float H) {
    float laplacian = compute_laplacian_vorticity(vorticity, i, j, du);
    return -H * laplacian;
}
```

### 3.3 Physical Interpretation

**Positive w_c (upward):** Convergence of vorticity → rising air → cloud formation
**Negative w_c (downward):** Divergence of vorticity → sinking air → clear skies

---

## 4. Feedback into Buoyancy and Convection

### 4.1 Buoyancy Modification

**Standard Buoyancy (without torsion):**

```
b = g · (θ - θ_ref) / θ_ref
```

Where:
- `g = 9.81 m/s²`: Gravitational acceleration
- `θ`: Potential temperature
- `θ_ref`: Reference temperature

**Enhanced Buoyancy (with torsion):**

```
b_eff = b + α_torsion · w_c
```

**Parameters:**
- `α_torsion = 0.1`: Torsion coupling coefficient (empirical)

**Rationale:** Upward pseudo-velocity amplifies buoyant updrafts (positive feedback).

**Implementation:**

```c
float compute_effective_buoyancy(float theta, float theta_ref, float w_c) {
    float g = 9.81f;
    float alpha_torsion = 0.1f;

    float buoyancy = g * (theta - theta_ref) / theta_ref;
    return buoyancy + alpha_torsion * w_c;
}
```

### 4.2 Convection Term Modification

**Standard Convective Acceleration:**

```
du/dt = ... - u · ∇u
```

**With Torsion (vorticity transport):**

```
du/dt = ... - u · ∇u + ε · (ω × u)
```

Where:
- `ε = 0.05`: Vortex force coupling coefficient

**Cross Product (ω × u):**

For 2D horizontal flow:

```
(ω × u)_x = -ω_z · u_y
(ω × u)_y = +ω_z · u_x
```

**Implementation:**

```c
typedef struct {
    float ax, ay;  // Acceleration components
} Acceleration2D;

Acceleration2D compute_vortex_force(float omega_z, Velocity2D vel, float epsilon) {
    Acceleration2D accel;
    accel.ax = -epsilon * omega_z * vel.u_v;
    accel.ay = +epsilon * omega_z * vel.u_u;
    return accel;
}
```

### 4.3 Temperature Advection Enhancement

**Standard Temperature Advection:**

```
∂θ/∂t = -u · ∇θ
```

**With Torsion (vertical mixing):**

```
∂θ/∂t = -u · ∇θ + β · w_c · (θ_aloft - θ)
```

**Parameters:**
- `β = 0.02`: Vertical mixing coefficient
- `θ_aloft`: Temperature at higher altitude (assumed constant ~270 K)

**Implementation:**

```c
float compute_temperature_change_with_torsion(float theta, float u_x, float u_y,
                                               float dtheta_dx, float dtheta_dy,
                                               float w_c, float theta_aloft, float dt) {
    // Standard advection
    float advection = -(u_x * dtheta_dx + u_y * dtheta_dy);

    // Torsion-driven vertical mixing
    float beta = 0.02f;
    float mixing = beta * w_c * (theta_aloft - theta);

    return (advection + mixing) * dt;
}
```

---

## 5. Integration with Atmospheric Solver (ATMv1)

### 5.1 Workflow

**Per Timestep:**
1. Compute horizontal velocity from atmospheric solver (u_u, u_v)
2. Compute vorticity (ω_z) using discrete curl
3. Compute vertical pseudo-velocity (w_c) from Laplacian of vorticity
4. Feed w_c into buoyancy and convection terms
5. Solve atmospheric equations with modified terms
6. Update velocity field

**Pseudocode:**

```c
void atmospheric_step_with_torsion(AtmosphericState* state, float dt) {
    // Step 1: Compute vorticity
    for (int i = 0; i < grid_size; i++) {
        for (int j = 0; j < grid_size; j++) {
            state->vorticity[i][j] = compute_vorticity_cubed_sphere(
                state->velocity, i, j, state->du, state->dv
            );
        }
    }

    // Step 2: Compute vertical pseudo-velocity
    for (int i = 0; i < grid_size; i++) {
        for (int j = 0; j < grid_size; j++) {
            state->w_c[i][j] = compute_vertical_pseudo_velocity(
                state->vorticity, i, j, state->du, 1000.0f
            );
        }
    }

    // Step 3: Solve atmospheric equations with modified buoyancy/convection
    for (int i = 0; i < grid_size; i++) {
        for (int j = 0; j < grid_size; j++) {
            float b_eff = compute_effective_buoyancy(
                state->theta[i][j], state->theta_ref, state->w_c[i][j]
            );

            Acceleration2D vortex_force = compute_vortex_force(
                state->vorticity[i][j], state->velocity[i][j], 0.05f
            );

            // Update velocity (simplified Euler)
            state->velocity[i][j].u_u += (b_eff + vortex_force.ax) * dt;
            state->velocity[i][j].u_v += vortex_force.ay * dt;

            // Update temperature
            float dtheta = compute_temperature_change_with_torsion(
                state->theta[i][j], state->velocity[i][j].u_u, state->velocity[i][j].u_v,
                compute_gradient_x(state->theta, i, j),
                compute_gradient_y(state->theta, i, j),
                state->w_c[i][j], 270.0f, dt
            );
            state->theta[i][j] += dtheta;
        }
    }
}
```

### 5.2 Stability Constraints

**CFL Condition (for explicit time integration):**

```
dt < min(Δu / |u_max|, Δu² / (2·ν))
```

Where:
- `ν`: Kinematic viscosity (~15 m²/s for air at 20°C)
- `u_max`: Maximum horizontal velocity

**Recommended Timestep:**
- `dt = 10 s` for 10 km grid spacing
- `dt = 1 s` for 1 km grid spacing

---

## 6. Validation and Testing

### 6.1 Synthetic Test Cases

**1. Solid-Body Rotation:**
- Initialize with constant angular velocity
- Vorticity should be spatially uniform
- w_c should be near-zero (no vorticity gradient)

**2. Point Vortex:**
- Single high-vorticity cell
- w_c should show dipole pattern (up/down)
- Decay rate matches theoretical prediction

**3. Shear Layer:**
- Velocity jump across horizontal line
- Vorticity concentrated in shear layer
- Kelvin-Helmholtz instability (if resolution sufficient)

### 6.2 Expected Behaviors

| Scenario | Expected ω_z | Expected w_c | Expected Feedback |
|----------|--------------|--------------|-------------------|
| Uniform flow | ~0 | ~0 | None |
| Cyclone | High positive | Negative (downdraft) | Enhanced convergence |
| Anticyclone | High negative | Positive (updraft) | Divergence |
| Jet stream | Concentrated band | Dipole | Rossby waves (if β-plane) |

### 6.3 Unit Tests

**Required Coverage:**
1. Curl operator accuracy (compare to analytical solutions)
2. Laplacian accuracy (compare to analytical Laplacian)
3. Edge transformation correctness (velocity continuity)
4. Energy conservation (kinetic + potential)
5. Vorticity conservation (∫ω_z dA = const for closed domain)

---

## 7. Performance Characteristics

### 7.1 Computational Cost

| Operation | Cost (per cell) | Fraction of Total |
|-----------|-----------------|-------------------|
| Vorticity computation | ~15 cycles | 10% |
| Laplacian computation | ~20 cycles | 15% |
| Buoyancy feedback | ~5 cycles | 3% |
| Vortex force | ~10 cycles | 7% |
| **Total Torsion Overhead** | **~50 cycles** | **35%** |

**Comparison:**
- Atmospheric solver (without torsion): ~150 cycles/cell
- With torsion: ~200 cycles/cell
- **Overhead: 33%**

### 7.2 Optimization Strategies

**SIMD Vectorization:**
- Process 4-8 cells simultaneously (AVX2/AVX512)
- Expected speedup: 2-3×

**Lookup Tables:**
- Precompute edge transformation matrices
- Store in 6×6 lookup table (36 entries)

**Adaptive Resolution:**
- Only compute torsion where |ω_z| > threshold
- Skip cells with negligible vorticity (~50% reduction in computation)

---

## 8. Future Extensions

### 8.1 Full 3D Vorticity

**Motivation:** Capture vertical vorticity structures (dust devils, tornadoes)

**Changes Required:**
- Add ω_x, ω_y components
- Full 3D velocity field (u_x, u_y, w)
- 3D curl operator

### 8.2 Vorticity Diffusion

**Turbulent Dissipation:**

```
∂ω_z/∂t = ... + ν_turb · ∇²ω_z
```

Where `ν_turb` is turbulent eddy viscosity (~10-100 m²/s).

### 8.3 Coriolis Effect (β-plane Approximation)

**For Planetary-Scale Flows:**

```
∂ω_z/∂t = ... + f · (∂v/∂x - ∂u/∂y)
```

Where `f = 2Ω sin(φ)` is the Coriolis parameter (latitude-dependent).

---

## 9. Data Structure Specifications

### 9.1 TorsionState Structure

```c
typedef struct {
    float** vorticity;          // [grid_size][grid_size]
    float** w_c;                // Vertical pseudo-velocity
    float** laplacian_omega;    // Cached Laplacian
    uint32_t grid_size;
    float du, dv;               // Grid spacing
    float H;                    // Characteristic height (1000 m)
} TorsionState;
```

### 9.2 Initialization

```c
TorsionState* torsion_state_create(uint32_t grid_size, float du, float dv) {
    TorsionState* state = malloc(sizeof(TorsionState));
    state->grid_size = grid_size;
    state->du = du;
    state->dv = dv;
    state->H = 1000.0f;

    // Allocate 2D arrays
    state->vorticity = allocate_2d_array(grid_size, grid_size);
    state->w_c = allocate_2d_array(grid_size, grid_size);
    state->laplacian_omega = allocate_2d_array(grid_size, grid_size);

    // Zero-initialize
    memset(state->vorticity[0], 0, grid_size * grid_size * sizeof(float));
    memset(state->w_c[0], 0, grid_size * grid_size * sizeof(float));
    memset(state->laplacian_omega[0], 0, grid_size * grid_size * sizeof(float));

    return state;
}
```

---

## 10. References

1. **Vorticity Dynamics:** Holton, J.R. "An Introduction to Dynamic Meteorology" (2012), Chapter 5
2. **Cubed-Sphere Grids:** Ronchi et al., "The 'Cubed-Sphere': A new method for the solution of PDEs on the sphere" (1996)
3. **Numerical Weather Prediction:** Durran, D.R. "Numerical Methods for Fluid Dynamics" (2010), Chapter 8
4. **Pseudo-Velocity Approximation:** Verkley & Vosbeek, "Vertical motion from vorticity in quasi-geostrophic flow" (1998)
5. **Kelvin-Helmholtz Instability:** Drazin & Reid, "Hydrodynamic Stability" (2004), Chapter 2

---

**Document Control:**
- **Approved by:** Technical Lead
- **Status:** Planned (awaiting ATMv1 completion)
- **Review Frequency:** Every release
- **Next Review:** v0.4.0-alpha
