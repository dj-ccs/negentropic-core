# negentropic-core v2.2 Upgrade Plan
# "Soul and Skin" — Structure-Preserving Physics + Living Interface

**Version:** v2.2 (v0.4.0)
**Sprint Duration:** 4 weeks
**Status:** Planning Phase
**Last Updated:** 2025-11-18

---

## Executive Summary

This document defines the complete upgrade path from v0.3.3 (production-ready core) to v2.2, implementing structure-preserving geometric integrators (the "Soul") and interactive user-facing features (the "Skin"). This upgrade represents a fundamental architectural enhancement while maintaining backward compatibility with existing SAB layout and cross-platform determinism.

**Key Achievement**: Upgrade from explicit RK4 integrators to LoD-gated, structure-preserving integrators (RKMK4 + Clebsch-Collective) while adding real-time user interaction capabilities.

---

## 1. Guiding Principles (MANDATORY)

### 1.1 v2.2 is for Deterministic Geometry ONLY

This sprint has a singular, ruthlessly focused mandate: implement the core geometric integrators with provable conservation properties and deterministic behavior across all platforms (WASM, embedded, Unity).

**What this means in practice:**
- Focus on RKMK4 (SE(3)) and Clebsch-Collective (Lie-Poisson) integrators
- Implement torsion as the discrete curl of velocity fields
- Ensure LoD-gated dispatch with error-based escalation
- Maintain fixed-point determinism and cross-platform reproducibility
- Validate conservation properties (Casimir drift < 1e-6, energy conservation)

**What this explicitly excludes:**
- Advanced physics models from CliMA (weak curl operators, spherical harmonics, multi-physics couplers)
- Ensemble/probabilistic infrastructure
- Advanced coupling strategies beyond basic momentum coupling
- Any features that compromise determinism or add unnecessary complexity

### 1.2 The "Doom Ethos" is Our Performance Bible

All implementation decisions must prioritize the performance strategies that map directly to our WASM and embedded targets. This is not optional—it is the foundation of our cross-platform strategy.

**Core "Doom Ethos" principles:**
1. **LUT-Heavy Arithmetic**: Precompute expensive functions (exp_map, reciprocals, sqrt) into lookup tables with linear interpolation
2. **Fixed-Point Helpers**: Implement Q16.16 fixed-point operations for all deterministic computations
3. **Predictable Memory Layouts**: Use pre-allocated memory slabs—no runtime `malloc` in hot paths
4. **Column-Major Access**: Organize data for cache-friendly sequential access patterns
5. **BSP-Style Culling**: Implement hierarchical spatial culling for rendering efficiency
6. **Minimize Branching**: Use branchless techniques and lookup tables instead of conditionals
7. **SIMD-Friendly Design**: Align data structures for potential SIMD vectorization

**Performance targets (non-negotiable):**
- Clebsch-Collective: < 220 ns/cell (x86-64), < 400 ns/cell (WASM)
- RKMK4: < 100 ns/step
- Torsion kernel: < 50 cycles/cell
- UI rendering: 60 FPS @ 100×100 grid with full physics
- Memory overhead: < 10% increase over v0.3.3

---

## 2. Strictly Out of Scope for v2.2

The following items are **explicitly deferred** to future sprints (v2.4+). Do not implement, import, or reference these concepts during the v2.2 sprint:

### 2.1 Advanced CliMA Physics
- **Weak curl operators**: Use simple discrete curl (5-7 point stencil) instead
- **Spherical harmonic decomposition**: Defer to geodesic modeling sprint
- **Multi-physics couplers**: Basic momentum coupling only for v2.2
- **Advanced spectral methods**: Stick to spatial discretization
- **Flux-corrected transport**: Use simple upwind schemes

### 2.2 Probabilistic/Ensemble Infrastructure
- **Ensemble forecasting**: Single deterministic trajectory only
- **Uncertainty quantification**: No UQ infrastructure in v2.2
- **Stochastic forcing**: Deterministic forcings only
- **Monte Carlo sampling**: Not needed for geometric integrators

### 2.3 Advanced Numerical Features
- **Adaptive mesh refinement**: Static LoD levels only
- **High-order spatial schemes**: 2nd-order finite differences sufficient
- **Implicit solvers**: Explicit integrators only (with symplectic structure)
- **Multigrid methods**: Direct solve or simple iterative solvers

### 2.4 Platform-Specific Optimizations (Deferred to v2.3)
- **Unity P/Invoke integration**: Web/WASM target only for v2.2
- **Mobile-specific UI**: Desktop/tablet browser focus
- **Native mobile builds**: Web deployment only
- **GPU compute shaders**: Rendering-only GPU usage

### 2.5 Advanced User Features
- **Multiplayer synchronization**: Single-user scenarios only
- **Cloud save/load**: localStorage only for v2.2
- **Advanced analytics**: Basic event logging only
- **Social sharing**: URL-based scenario sharing only

**Rationale**: These deferred items either introduce unnecessary complexity, compromise determinism, or do not directly support the core geometric integrator implementation. By deferring them, we can maintain ruthless focus on building a rock-solid foundation that can support these features in future sprints.

---

## 3. Strategic Context

### 3.1 Current State (v0.3.3)
- ✅ HYD-RLv1/v2 production ready
- ✅ REGv1/v2 production ready
- ✅ SAB memory architecture stable
- ✅ ORACLE-004 CesiumJS/deck.gl sync complete
- ✅ Fixed-point Q16.16 deterministic math
- ✅ SE(3) pose infrastructure
- ✅ Web Worker architecture (Main/Core/Render)

### 3.2 Target State (v2.2)
- Structure-preserving integrators with provable conservation properties
- Torsion as first-class physical variable (drives momentum + cloud seeding)
- LoD-gated dispatch (RK4 coarse, RKMK4+Clebsch fine)
- Interactive scenario editor with event logging
- Real-time difference map visualization
- Visual torsion effects in cloud rendering

### 3.3 Dependencies & Prerequisites
- **ORACLE-004 Complete**: Raw matrix injection architecture is stable
- **SAB v0.3.3**: Memory layout provides foundation for torsion field
- **docs/integrators.md**: Canonical mathematical specification
- **Existing SE(3) Infrastructure**: `embedded/se3_math.c` provides foundation for RKMK4

---

## 4. Two-Track Architecture

### Track 1: [PHYS-v2.2] The Soul — Structure-Preserving Physics Core
**Goal**: Implement LoD-gated, multi-integrator stack with provable conservation properties

**Timeline**: Weeks 1-3
**Lead**: Physics Core Team
**Deliverable**: Production-ready integrator stack with passing conservation tests

### Track 2: [GEO-v2] The Skin — Living Globe Interface
**Goal**: Implement user-facing interactive features

**Timeline**: Weeks 2-4 (parallel with Track 1)
**Lead**: Visualization Team
**Deliverable**: Interactive scenario editor with real-time visualization

---

## 5. Track 1: [PHYS-v2.2] Implementation Plan

### 5.1 Phase 1.1: Torsion Kernel (Week 1)

#### 5.1.1 Directory Structure
```
src/core/torsion/
├── torsion.h              # API header (from integrators.md)
├── torsion.c              # Main implementation
├── discrete_curl.c        # Discrete curl operator
└── torsion_tendency.c     # Momentum coupling
```

#### 5.1.2 SAB Layout Extension
**Current SAB Header (v0.3.3)**: 128 bytes
**Modification**: Use existing `offset_torsion` field (already reserved in v0.3.3)

```c
// In Memory_Architecture_and_SAB_Layout_v0.3.3.md
uint32_t offset_torsion;  // Already exists at byte offset 96
```

**New Torsion Data Layout** (per cell):
```c
typedef struct {
    fixed_t wx;     // 4 bytes: x-component of vorticity (Q16.16)
    fixed_t wy;     // 4 bytes: y-component
    fixed_t wz;     // 4 bytes: z-component
    fixed_t mag;    // 4 bytes: magnitude (for shader access)
} neg_torsion_t;  // Total: 16 bytes per cell
```

**SAB Offset Calculation**:
```c
// For 100×100 grid:
// offset_torsion = offset_precipitation + (num_entities * sizeof(fixed_t))
// Size: num_entities * 16 bytes (4 fixed_t values)
```

#### 5.1.3 Implementation Tasks

**Task 1.1.1**: Create torsion API header
- File: `src/core/torsion/torsion.h`
- Content: Exact API from `docs/integrators.md` section 4.2
- Dependencies: `state.h`, `platform.h`

**Task 1.1.2**: Implement discrete curl operator
- File: `src/core/torsion/discrete_curl.c`
- Algorithm: CliMA-style weak curl (5-7 point stencil)
- Reference pseudocode: Section 1 of ORACLE Fusion appendix
- Handle cubed-sphere edge continuity

**Task 1.1.3**: Implement torsion tendency coupling
- File: `src/core/torsion/torsion_tendency.c`
- Function: `apply_torsion_tendency(GridCell* cell, const neg_torsion_t* t, double dt)`
- Physics: Conservative momentum increment (α = 1e-3)

**Task 1.1.4**: Update SAB writer
- File: `src/core/state.c`
- Modify: `state_step()` to call `compute_torsion_tile()`
- Write: torsion data to SAB at correct offset

**Task 1.1.5**: Create unit tests
- File: `tests/torsion_unit_test.c`
- Tests:
  - Analytic velocity → discrete curl (L2 error < 1e-4)
  - Solid-body rotation (should produce constant ω)
  - Point vortex (compare to analytical solution)

**Validation Criteria**:
- [ ] All unit tests pass (3/3)
- [ ] Performance: <50 cycles/cell (embedded target)
- [ ] SAB torsion field populated correctly
- [ ] No memory leaks (valgrind clean)

---

### 5.2 Phase 1.2: RKMK4 for SE(3) (Week 1)

#### 5.2.1 Directory Structure
```
src/core/integrators/
├── integrators.h          # Master API (from integrators.md)
├── rkmk4.c               # RKMK4 implementation
├── se3_integrator.c      # SE(3) helper functions
└── workspace.h           # Workspace allocation
```

#### 3.2.2 Workspace Structure
```c
// src/core/integrators/workspace.h
typedef struct {
    // RKMK4 scratch space
    double k1[6];  // Lie algebra stages
    double k2[6];
    double k3[6];
    double k4[6];
    double exp_scratch[9];  // For exp_map computation

    // Clebsch scratch space
    double q_temp[8];
    double p_temp[8];
    double force_buffer[8];

    // LUT handles (if using table-driven approach)
    void* clebsch_lut;
    void* exp_lut;
} IntegratorWorkspace;
```

#### 3.2.3 Implementation Tasks

**Task 1.2.1**: Create integrator master API
- File: `src/core/integrators/integrators.h`
- Content: Exact API from `docs/integrators.md` section 4.1
- Enum: `integrator_e` with all method types

**Task 1.2.2**: Implement RKMK4 core
- File: `src/core/integrators/rkmk4.c`
- Algorithm: 4th-order Runge-Kutta-Munthe-Kaas
- Reference: `embedded/se3_math.c` for existing SE(3) operations
- Key functions:
  - `rkmk4_step_se3()`: Main integrator
  - `lie_bracket()`: Commutator for BCH truncation
  - `exp_map()`: Lie algebra → group (use LUT or series)

**Task 1.2.3**: Create exp_map LUT (Doom-style)
- File: `src/core/integrators/exp_lut.c`
- Size: 8192 entries (32 KB)
- Coverage: Small angle regime (|ξ| < π/4)
- Fallback: Taylor series for large angles

**Task 1.2.4**: Implement workspace management
- File: `src/core/integrators/workspace.c`
- Functions:
  - `workspace_create()`
  - `workspace_destroy()`
  - `workspace_reset()`

**Task 1.2.5**: Create integration tests
- File: `tests/test_rkmk4.c`
- Tests:
  - Constant angular velocity (should maintain orthogonality)
  - Torque-free rotation (energy conservation)
  - Comparison with FP64 oracle

**Validation Criteria**:
- [ ] Orthogonality error < 1e-10 (after 10k steps)
- [ ] Energy drift < 1e-6/year (for constant torque)
- [ ] Performance: <100 ns/step (x86-64 target)
- [ ] Deterministic across platforms

---

### 5.3 Phase 1.3: Clebsch-Collective Integrator (Week 2)

#### 3.3.1 Directory Structure
```
src/core/integrators/
├── clebsch.h              # Clebsch API (from integrators.md)
├── clebsch_collective.c   # Main integrator
├── clebsch_lift.c         # LP → canonical
├── clebsch_project.c      # canonical → LP
├── symplectic_rk.c        # Symplectic RK stages
└── clebsch_lut.c          # LUT-accelerated lift/project
```

#### 3.3.2 Clebsch LUT Specification
**Purpose**: Accelerate lift/project via precomputed transformations

**LUT Structure**:
```c
typedef struct {
    uint16_t num_bins;        // 256 or 512
    fixed_t* q_table;         // Canonical q values
    fixed_t* p_table;         // Canonical p values
    fixed_t* casimir_table;   // Expected Casimir values
} ClebschLUT;
```

**Binning Strategy**:
- Bin by vorticity magnitude: `|ω| ∈ [0, ω_max]`
- 256 bins for 256-entry LUT (fits in 4 KB)
- Linear interpolation between bins

#### 3.3.3 Implementation Tasks

**Task 1.3.1**: Implement Clebsch lift
- File: `src/core/integrators/clebsch_lift.c`
- Function: `clebsch_lift(const LPVar* m, ClebschWorkspace* ws, double* q_out, double* p_out)`
- Algorithm: Table-driven linear transform (from docs/integrators.md)
- Fallback: Analytic lift if LUT unavailable

**Task 1.3.2**: Implement Clebsch project
- File: `src/core/integrators/clebsch_project.c`
- Function: `clebsch_project(const double* q, const double* p, ClebschWorkspace* ws, LPVar* m_out)`
- Algorithm: Inverse transform + Casimir correction

**Task 1.3.3**: Implement symplectic RK
- File: `src/core/integrators/symplectic_rk.c`
- Function: `clebsch_symplectic_step()`
- Algorithm: Velocity-Verlet or 2-stage PRK (from pseudocode appendix)
- Newton iteration: Bounded by `max_iter` (default: 4)
- Fallback: Single explicit step if iteration doesn't converge

**Task 1.3.4**: Generate Clebsch LUT
- File: `tools/generate_clebsch_lut.py`
- Method: SymPy symbolic solver for discrete bracket
- Output: C header with static const arrays
- Validation: Check Casimir preservation < 1e-6

**Task 1.3.5**: Create conservation tests
- File: `tests/integrator_conservation_test.c`
- Tests (from docs/integrators.md section 6):
  - Casimir drift < 1e-10 (FP64), < 1e-6 (fixed-point)
  - Energy drift over 10-year Loess Plateau run
  - Reversibility (forward/backward integration)

**Validation Criteria**:
- [ ] Casimir drift < 1e-6 (fixed-point)
- [ ] Performance: <220 ns/cell (WASM target)
- [ ] LUT memory: <8 KB total
- [ ] All conservation tests pass (3/3)

---

### 5.4 Phase 1.4: LoD Gating & Dispatch (Week 2)

#### 3.4.1 LoD Policy Specification

**LoD Levels** (from existing LoD spec v0.3.3):
```
Level 0: 16×16   (100 km spacing) → RK4
Level 1: 32×32   (50 km)          → RK4 + Hybrid Variational
Level 2: 64×64   (25 km)          → RKMK4 + Clebsch-Collective
Level 3: 128×128 (12.5 km)        → RKMK4 + Clebsch-Collective
```

**Torsion Computation Gating**:
- LoD 0-1: Torsion NOT computed (set to zero)
- LoD 2-3: Torsion computed and applied

**Dynamic Escalation**:
- If RK4 error > threshold → escalate to RKMK4 for that cell
- If RKMK4 error > threshold → escalate to Clebsch for that cell
- Track escalation count for performance monitoring

#### 3.4.2 Implementation Tasks

**Task 1.4.1**: Modify state_step dispatcher
- File: `src/core/state.c`
- Function: `state_step(void* sim, float dt)`
- Algorithm:
  ```c
  for each tile {
      int lod = compute_lod(tile);
      if (lod < 2) {
          rk4_step(tile);
      } else {
          compute_torsion_tile(S, x0, y0, nx, ny);
          if (tile->requires_se3) {
              rkmk4_step(tile);
          }
          if (tile->requires_clebsch) {
              clebsch_collective_step(tile, dt, cfg, ws);
          }
          apply_torsion_tendency(tile);
      }
  }
  ```

**Task 1.4.2**: Implement error-based escalation
- File: `src/core/integrators/error_estimator.c`
- Function: `estimate_integration_error()`
- Thresholds:
  - RK4 → RKMK4: error > 1e-4
  - RKMK4 → Clebsch: error > 1e-6

**Task 1.4.3**: Create LoD integration test
- File: `tests/test_lod_dispatch.c`
- Scenarios:
  - Verify LoD 0-1 use RK4 only
  - Verify LoD 2+ compute torsion
  - Verify escalation triggers correctly

**Validation Criteria**:
- [ ] Correct integrator selected per LoD level
- [ ] Torsion only computed for LoD ≥ 2
- [ ] Escalation reduces global error
- [ ] Performance: <10% overhead vs. v0.3.3

---

### 5.5 Phase 1.5: Science Ports (Week 3)

#### 3.5.1 Medlyn Stomatal Conductance

**Location**: `src/solvers/regeneration_cascade.c` (REGv2)
**Current**: Simple linear transpiration model
**Upgrade**: Medlyn stomatal conductance from CliMA Land v0.11

**Implementation**:
```c
// From CliMA Land PlantHydraulics.jl
fixed_t medlyn_gs(fixed_t lai, fixed_t theta_root, fixed_t rh, fixed_t T) {
    // g1 parameter from PFT lookup table
    fixed_t g1 = get_g1_param(pft_type);

    // Medlyn model: gs = g0 + 1.6(1 + g1/√VPD)(A/ca)
    // Simplified for REGv2: gs = g1 * lai * sqrt(theta_root) * rh
    fixed_t gs = FixedMul(g1, lai);
    gs = FixedMul(gs, fixed_sqrt(theta_root));  // Use LUT-based sqrt
    gs = FixedMul(gs, rh);

    return gs;
}
```

**Task 1.5.1**: Port Medlyn model to fixed-point
**Task 1.5.2**: Create PFT parameter table (g1 values)
**Task 1.5.3**: Integrate into transpiration flux calculation

#### 3.5.2 SoilCO2 Microbial F:B Ratio

**Location**: `src/solvers/regeneration_microbial.c` (REGv2)
**Current**: 8-entry LUT for priming effect
**Upgrade**: Continuous F:B response function

**Implementation**:
```c
// From CliMA Land SoilCO2Model.jl
fixed_t f_b_response(fixed_t theta, fixed_t T, fixed_t N_fix) {
    // Monod kinetics for uptake
    fixed_t uptake = FixedMul(theta, N_fix);

    // Lloyd-Taylor temperature response for decay
    fixed_t decay = exp_LloydTaylor(T);  // Use existing LUT

    // F:B ratio drives SOM production
    fixed_t f_b = FixedDiv(uptake, uptake + decay);

    return f_b;
}
```

**Task 1.5.4**: Implement continuous F:B function
**Task 1.5.5**: Replace 8-entry LUT with continuous model
**Task 1.5.6**: Validate against CliMA benchmarks

#### 3.5.3 Dual-Porosity Hydraulic Conductivity

**Location**: `src/solvers/hydrology_richards_lite.c` (HYD-RLv2)
**Current**: Van Genuchten K(θ) with 256-entry LUT
**Upgrade**: Dual-porosity enhancement

**Implementation**:
```c
// Enhanced K(θ) with aggregation effect
fixed_t K_dual_porosity(fixed_t theta, fixed_t SOM, fixed_t f_agg) {
    // Base conductivity from VG LUT
    fixed_t K_base = K_van_genuchten_LUT(theta);

    // Aggregation enhancement (from SOM)
    fixed_t agg_factor = FIXED_ONE + FixedMul(f_agg, SOM);

    // Enhanced conductivity
    return FixedMul(K_base, agg_factor);
}
```

**Task 1.5.7**: Implement dual-porosity K(θ) enhancement
**Task 1.5.8**: Add aggregation factor calculation
**Task 1.5.9**: Validate infiltration improvement

**Validation Criteria (Phase 1.5)**:
- [ ] Medlyn gs integrated into transpiration
- [ ] F:B ratio drives SOM production continuously
- [ ] Dual-porosity K(θ) improves infiltration in high-SOM cells
- [ ] All solver tests pass (regression check)

---

### 5.6 Phase 1.6: CI/CD & Validation (Week 3)

#### 3.6.1 Test Infrastructure Updates

**New Test Files**:
```
tests/
├── integrator_conservation_test.c  # Casimir/energy drift
├── integrator_reversibility_test.c # Forward/backward
├── torsion_unit_test.c             # Discrete curl validation
├── test_baroclinic_wave.c          # CliMA oracle test
├── test_rkmk4.c                    # SE(3) integration
├── test_lod_dispatch.c             # LoD gating
└── test_clebsch_collective.c       # Symplectic integration
```

#### 3.6.2 CI Pipeline Updates

**File**: `.github/workflows/oracle_validation.yml`

**New Steps**:
```yaml
- name: Run v2.2 Conservation Tests
  run: |
    ./tests/integrator_conservation_test
    ./tests/integrator_reversibility_test

- name: Run Torsion Tests
  run: ./tests/torsion_unit_test

- name: Run CliMA Oracle Comparison
  run: |
    python3 tests/oracle/test_baroclinic_wave.py
    python3 tests/oracle/compare_integrators.py

- name: Performance Benchmarks
  run: |
    ./tests/physics_integration_benchmark
    # Fail if Clebsch > 220 ns/cell
```

#### 3.6.3 Validation Thresholds

**Conservation Tests** (from docs/integrators.md section 8):
- Casimir drift: `< 1e-10` (FP64), `< 1e-6` (fixed-point)
- Energy drift: `< 1e-6` over 10 years
- Reversibility: L2 error `< 1e-10` (FP64)

**Performance Guards**:
- Clebsch-Collective: `< 220 ns/cell` (median, x86-64)
- RKMK4: `< 100 ns/step`
- Torsion kernel: `< 50 cycles/cell`

**Task 1.6.1**: Implement all test files
**Task 1.6.2**: Update CI/CD pipeline
**Task 1.6.3**: Create performance regression detector
**Task 1.6.4**: Document validation protocol in `docs/integrators_math_appendix.md`

**Validation Criteria**:
- [ ] All conservation tests pass
- [ ] All performance benchmarks meet targets
- [ ] CI pipeline runs successfully
- [ ] No regressions in existing tests

---

## 6. Track 2: [GEO-v2] Implementation Plan

### 6.1 Phase 2.1: Difference Map Layer (4 hours)

#### 4.1.1 Requirements
- Visualize restoration/degradation relative to baseline
- GPU shader: `diff = current - baseline`
- Color coding: green (restoration), red (degradation)
- Toggle: "Show Restoration" in UI

#### 4.1.2 Architecture
```
web/src/layers/
├── DifferenceMapLayer.ts    # Custom deck.gl layer
└── shaders/
    ├── difference-vertex.glsl
    └── difference-fragment.glsl
```

#### 4.1.3 Shader Logic
```glsl
// difference-fragment.glsl
uniform sampler2D u_baseline;
uniform sampler2D u_current;

void main() {
    vec2 uv = gl_FragCoord.xy / resolution;

    float baseline = texture2D(u_baseline, uv).r;
    float current = texture2D(u_current, uv).r;

    float diff = current - baseline;

    // Color mapping
    vec3 color;
    if (diff > 0.0) {
        // Restoration: green gradient
        color = mix(vec3(0.0, 0.5, 0.0), vec3(0.0, 1.0, 0.0), diff / 0.5);
    } else {
        // Degradation: red gradient
        color = mix(vec3(0.5, 0.0, 0.0), vec3(1.0, 0.0, 0.0), abs(diff) / 0.5);
    }

    gl_FragColor = vec4(color, 0.8);
}
```

#### 4.1.4 Implementation Tasks

**Task 2.1.1**: Create DifferenceMapLayer class
- File: `web/src/layers/DifferenceMapLayer.ts`
- Extend: `deck.gl Layer`
- Props:
  - `baselineTexture: WebGLTexture`
  - `currentTexture: WebGLTexture`
  - `opacity: number`

**Task 2.1.2**: Implement custom shaders
- Files: `difference-vertex.glsl`, `difference-fragment.glsl`
- Vertex shader: Standard passthrough
- Fragment shader: Difference calculation + color mapping

**Task 2.1.3**: Add UI toggle
- File: `web/src/ui/ControlPanel.tsx`
- Component: `<Toggle label="Show Restoration" />`
- State: `showDifferenceMap: boolean`

**Task 2.1.4**: Integrate with render worker
- File: `web/src/workers/render-worker.ts`
- Add layer to deck.gl stack when toggle enabled
- Pass baseline/current textures from SAB data

**Validation Criteria**:
- [ ] Difference map renders correctly
- [ ] Green shows restoration, red shows degradation
- [ ] Toggle works without crashes
- [ ] Performance: 60 FPS @ 100×100 grid

---

### 6.2 Phase 2.2: Scenario Editor Control Panel (4 hours)

#### 4.2.1 Requirements
- dat.GUI-based parameter editor
- Expose key physics parameters (r_V, eta1, K_sat, etc.)
- Live update simulation state
- Persist settings to localStorage

#### 4.2.2 Architecture
```
web/src/ui/
├── ScenarioEditor.ts        # dat.GUI wrapper
├── ParameterGroups.ts       # Organized param definitions
└── ScenarioPresets.ts       # Pre-configured scenarios
```

#### 4.2.3 Parameter Groups
```typescript
// ParameterGroups.ts
export const VEGETATION_PARAMS = {
  r_V: { min: 0.0, max: 1.0, step: 0.01, default: 0.15 },
  K_V: { min: 0.0, max: 1.0, step: 0.05, default: 0.95 },
  lambda1: { min: 0.0, max: 5.0, step: 0.1, default: 1.2 },
};

export const SOIL_PARAMS = {
  eta1: { min: 0.0, max: 2.0, step: 0.05, default: 0.8 },
  a1: { min: 0.0, max: 0.1, step: 0.001, default: 0.012 },
  a2: { min: 0.0, max: 0.1, step: 0.001, default: 0.008 },
};

export const HYDROLOGY_PARAMS = {
  K_sat: { min: 0.1, max: 100.0, step: 0.1, default: 10.0 },
  theta_sat: { min: 0.3, max: 0.6, step: 0.01, default: 0.45 },
};
```

#### 4.2.4 Implementation Tasks

**Task 2.2.1**: Create ScenarioEditor class
- File: `web/src/ui/ScenarioEditor.ts`
- Library: dat.GUI (add to package.json)
- Methods:
  - `addParameterGroup(name, params)`
  - `onParamChange(callback)`
  - `loadPreset(name)`

**Task 2.2.2**: Implement parameter change handler
- File: `web/src/workers/core-worker.ts`
- Message: `{ type: 'UPDATE_PARAM', name, value }`
- Update simulation config without restart

**Task 2.2.3**: Create preset scenarios
- File: `web/src/ui/ScenarioPresets.ts`
- Presets:
  - "Baseline Degraded" (current defaults)
  - "Aggressive Restoration" (high r_V, low runoff)
  - "Loess Plateau Historical" (1995-2010 calibration)

**Task 2.2.4**: Add localStorage persistence
- Save: On parameter change
- Load: On app initialization
- Key: `negentropic-scenario-v2`

**Validation Criteria**:
- [ ] All parameter groups display correctly
- [ ] Slider changes update simulation in real-time
- [ ] Presets load correctly
- [ ] Settings persist across browser sessions

---

### 6.3 Phase 2.3: Intervention Event System (6 hours)

#### 4.3.1 Requirements
- Hash-chained JSON event log
- Every user action generates an event
- "Share Scenario" encodes event log to URL
- Replay capability from event log

#### 4.3.2 Event Schema
```typescript
// From User_Events_and_Hash_Chained_Log_Standard_v0.3.3.md
interface Event {
  event_id: string;           // UUID v4
  timestamp_us: number;       // Microseconds since epoch
  event_type: EventType;      // Enum
  session_id: string;         // Session UUID
  user_id: string;            // Anonymous or authenticated
  prev_hash: string;          // SHA-256 of previous event
  hash: string;               // SHA-256 of this event
  schema_version: number;     // 1
  payload: any;               // Event-specific data
}

type EventType =
  | 'session_start'
  | 'session_end'
  | 'place_intervention'
  | 'remove_intervention'
  | 'change_parameter'
  | 'camera_move'
  | 'simulation_step'
  | 'checkpoint';
```

#### 4.3.3 Implementation Tasks

**Task 2.3.1**: Create Event Logger class
- File: `web/src/events/EventLogger.ts`
- Methods:
  - `logEvent(type, payload)`
  - `getEventLog(): Event[]`
  - `computeHash(event): string`
  - `validateChain(): boolean`

**Task 2.3.2**: Implement hash chaining
- Algorithm: SHA-256 (use SubtleCrypto API)
- Chain: Each event hashes previous event
- Genesis: First event has `prev_hash = "0000...0000"`

**Task 2.3.3**: Implement "Share Scenario" feature
- File: `web/src/ui/ShareButton.tsx`
- Encoding: LZMA-compressed event log → base64 → URL param
- URL format: `?scenario={base64_compressed_log}`
- Max URL length: 2048 chars (warn if exceeded)

**Task 2.3.4**: Implement replay system
- File: `web/src/replay/EventReplayer.ts`
- Process:
  1. Parse URL param
  2. Decompress event log
  3. Validate hash chain
  4. Apply events in order
  5. Update simulation state

**Task 2.3.5**: Add event hooks
- Parameter change: Log when user adjusts slider
- Intervention: Log when user places/removes intervention
- Camera move: Log significant camera movements (debounced)

**Validation Criteria**:
- [ ] Event log captures all user actions
- [ ] Hash chain validates correctly
- [ ] Shared URLs load and replay correctly
- [ ] Event log overhead < 1% (per v0.3.3 spec)
- [ ] Replay produces identical state hash

---

### 6.4 Phase 2.4: Visual Torsion Twist (2 hours)

#### 4.4.1 Requirements
- Use torsion magnitude to add visual turbulence to cloud layer
- GPU-based computation using `dFdx/dFdy` derivatives
- No impact on physics (visual-only effect)

#### 4.4.2 Architecture
```
web/src/layers/
└── shaders/
    └── cloud-particles-fragment.glsl
```

#### 4.4.3 Shader Implementation
```glsl
// cloud-particles-fragment.glsl
uniform sampler2D u_wind_field;
uniform sampler2D u_torsion_field;

void main() {
    vec2 uv = gl_FragCoord.xy / resolution;

    // Sample wind field
    vec2 wind = texture2D(u_wind_field, uv).xy;

    // Compute vorticity using GPU derivatives
    float dvdx = dFdx(wind.y);
    float dudy = dFdy(wind.x);
    float vorticity = dvdx - dudy;

    // Sample torsion magnitude from physics
    float torsion = texture2D(u_torsion_field, uv).a;

    // Combine for turbulent density
    float turbulence = abs(vorticity) + torsion * 0.5;

    // Apply to cloud particle density
    float density = base_density * (1.0 + turbulence * 2.0);

    // Color based on turbulence
    vec3 color = mix(
        vec3(1.0, 1.0, 1.0),      // White (calm)
        vec3(0.8, 0.8, 1.0),      // Blue-tinted (turbulent)
        clamp(turbulence, 0.0, 1.0)
    );

    gl_FragColor = vec4(color, density);
}
```

#### 4.4.4 Implementation Tasks

**Task 2.4.1**: Modify cloud particle shader
- File: `web/src/layers/shaders/cloud-particles-fragment.glsl`
- Add: Torsion texture uniform
- Add: Vorticity calculation via derivatives

**Task 2.4.2**: Pass torsion data to shader
- File: `web/src/workers/render-worker.ts`
- Create: WebGL texture from SAB torsion field
- Pass: As uniform to cloud layer

**Task 2.4.3**: Add turbulence intensity control
- File: `web/src/ui/ScenarioEditor.ts`
- Parameter: `torsion_visual_intensity` (0.0 to 2.0)

**Validation Criteria**:
- [ ] Clouds show visible turbulence in high-torsion regions
- [ ] Effect scales correctly with torsion magnitude
- [ ] No performance impact (still 60 FPS @ 100k particles)
- [ ] Intensity control works correctly

---

## 7. Integration & Final Sprint (Week 4)

### 7.1 Integration Tasks

**Task 5.1**: Merge Track 1 and Track 2 changes
**Task 5.2**: Full regression test suite (all v0.3.3 + v2.2 tests)
**Task 5.3**: Performance profiling and optimization
**Task 5.4**: Documentation updates

### 7.2 Documentation Updates

**Files to Update**:
- `architecture/Architectural_Quick-Ref.md` → v2.2
- `architecture/Core_Physics_Specification_v0.3.3.md` → Add integrators section
- `docs/integrators_math_appendix.md` → NEW (detailed derivations)
- `README.md` → Update feature list and performance metrics

### 7.3 Final Deliverables

**Code Deliverables**:
- [ ] All v2.2 integrators implemented and tested
- [ ] Torsion field computed and coupled to physics
- [ ] LoD-gated dispatch functional
- [ ] All UI features implemented
- [ ] Event logging system complete

**Documentation Deliverables**:
- [ ] `docs/v2.2_Upgrade.md` (this document)
- [ ] `docs/PHYS-v2.2_Progress.md` (tracking doc)
- [ ] `docs/GEO-v2_Progress.md` (tracking doc)
- [ ] `docs/integrators_math_appendix.md` (mathematical details)
- [ ] Updated architecture docs

**Validation Deliverables**:
- [ ] All conservation tests pass
- [ ] All performance benchmarks meet targets
- [ ] 10-year Loess Plateau run completes with Casimir drift < 1e-6
- [ ] Cross-platform determinism validated (WASM + Unity)

---

## 8. Progress Tracking

### 8.1 Week 1 Milestones
- [ ] Torsion kernel complete (Task 1.1)
- [ ] RKMK4 complete (Task 1.2)
- [ ] SAB torsion field populated
- [ ] Unit tests passing (torsion + RKMK4)

### 8.2 Week 2 Milestones
- [ ] Clebsch-Collective complete (Task 1.3)
- [ ] LoD dispatch complete (Task 1.4)
- [ ] Difference Map layer complete (Task 2.1)
- [ ] Scenario Editor complete (Task 2.2)

### 8.3 Week 3 Milestones
- [ ] Science ports complete (Medlyn, F:B, dual-porosity)
- [ ] All conservation tests passing
- [ ] CI/CD pipeline updated
- [ ] Event system complete (Task 2.3)
- [ ] Visual torsion complete (Task 2.4)

### 8.4 Week 4 Milestones
- [ ] Full integration complete
- [ ] All documentation updated
- [ ] Performance targets met
- [ ] v2.2 ready for production

---

## 9. Risk Assessment & Mitigation

### 9.1 Technical Risks

**Risk 1**: Clebsch LUT generation may not converge
- **Mitigation**: Implement analytic fallback for lift/project
- **Owner**: Physics team
- **Status**: Monitoring

**Risk 2**: Performance targets may not be met
- **Mitigation**: Profile early, optimize hot paths, use SIMD where possible
- **Owner**: Performance team
- **Status**: Monitoring

**Risk 3**: SAB layout extension may break existing code
- **Mitigation**: Use reserved offset (already in v0.3.3), add backward compat checks
- **Owner**: Core team
- **Status**: Low risk

### 9.2 Schedule Risks

**Risk 1**: Track 1 delays block Track 2 integration
- **Mitigation**: Track 2 can proceed with stub torsion data
- **Owner**: Project lead
- **Status**: Low risk

**Risk 2**: CI/CD updates take longer than expected
- **Mitigation**: Parallelize test development with feature work
- **Owner**: DevOps team
- **Status**: Low risk

---

## 10. Decisions Left to Make

### 10.1 Clebsch LUT Parameters
- [ ] **Decision**: LUT size (256 or 512 bins)?
  - **Tradeoff**: Memory (4 KB vs 8 KB) vs accuracy
  - **Recommendation**: Start with 256, escalate if error > 1e-5

- [ ] **Decision**: Fixed-point or FP64 for Clebsch internals?
  - **Tradeoff**: Determinism vs performance
  - **Recommendation**: FP64 for Clebsch, convert to fixed-point after project

### 10.2 Torsion Coupling Strength
- [ ] **Decision**: Momentum coupling coefficient α?
  - **Current**: α = 1e-3 (from integrators.md)
  - **Question**: Should this be LoD-dependent?
  - **Recommendation**: Start with constant, add LoD scaling if needed

### 10.3 Event Log Compression
- [ ] **Decision**: LZMA or simpler compression?
  - **Tradeoff**: Compression ratio vs client-side overhead
  - **Recommendation**: LZMA for "Share" feature, raw JSON for local storage

### 10.4 Unity Integration Timing
- [ ] **Decision**: Include Unity P/Invoke in v2.2 or defer to v2.3?
  - **Current**: Marked as "planned" in v0.3.3
  - **Recommendation**: Defer to v2.3 (focus on Web first)

---

## 11. Next Steps (Immediate Actions)

1. **Create progress tracking documents**:
   - `docs/PHYS-v2.2_Progress.md`
   - `docs/GEO-v2_Progress.md`

2. **Set up directory structure**:
   ```bash
   mkdir -p src/core/integrators
   mkdir -p src/core/torsion
   mkdir -p web/src/layers/shaders
   mkdir -p web/src/ui
   mkdir -p web/src/events
   mkdir -p tests/integrators
   ```

3. **Create stub files** (from integrators.md):
   - `src/core/integrators/integrators.h`
   - `src/core/torsion/torsion.h`
   - `src/core/integrators/clebsch.h`

4. **Update SAB header**:
   - Verify `offset_torsion` is correctly defined
   - Add torsion field size calculation to state.c

5. **Kick off Track 1, Phase 1.1**: Torsion Kernel
   - Assign: Physics team
   - Target: Week 1 completion

---

## 12. Appendix: Full File Manifest

### 12.1 New Core Files (Track 1)

```
src/core/integrators/
├── integrators.h              # Master API
├── integrators.c              # Dispatcher
├── rkmk4.c                   # RKMK4 for SE(3)
├── se3_integrator.c          # SE(3) helpers
├── clebsch.h                 # Clebsch API
├── clebsch_collective.c      # Main integrator
├── clebsch_lift.c            # LP → canonical
├── clebsch_project.c         # canonical → LP
├── symplectic_rk.c           # Symplectic stages
├── clebsch_lut.c             # LUT acceleration
├── exp_lut.c                 # Exp map LUT
├── error_estimator.c         # Error-based escalation
└── workspace.h               # Workspace allocation

src/core/torsion/
├── torsion.h                 # Torsion API
├── torsion.c                 # Main implementation
├── discrete_curl.c           # Discrete curl operator
└── torsion_tendency.c        # Momentum coupling

tools/
└── generate_clebsch_lut.py   # LUT generator (SymPy)
```

### 12.2 New Test Files

```
tests/
├── integrator_conservation_test.c
├── integrator_reversibility_test.c
├── torsion_unit_test.c
├── test_baroclinic_wave.c
├── test_rkmk4.c
├── test_lod_dispatch.c
├── test_clebsch_collective.c
└── oracle/
    ├── test_baroclinic_wave.py
    └── compare_integrators.py
```

### 12.3 New Web Files (Track 2)

```
web/src/layers/
├── DifferenceMapLayer.ts
└── shaders/
    ├── difference-vertex.glsl
    ├── difference-fragment.glsl
    └── cloud-particles-fragment.glsl

web/src/ui/
├── ScenarioEditor.ts
├── ParameterGroups.ts
├── ScenarioPresets.ts
└── ShareButton.tsx

web/src/events/
├── EventLogger.ts
└── EventReplayer.ts

web/src/replay/
└── EventReplayer.ts
```

### 12.4 Documentation Files

```
docs/
├── v2.2_Upgrade.md              # This document
├── PHYS-v2.2_Progress.md        # Track 1 progress
├── GEO-v2_Progress.md           # Track 2 progress
├── integrators_math_appendix.md # Mathematical derivations
└── integrators.md               # Canonical spec (existing)

architecture/
├── Architectural_Quick-Ref.md   # Updated to v2.2
└── Core_Physics_Specification_v0.4.0.md  # New version
```

---

## 13. Conclusion

This upgrade plan provides a complete, actionable roadmap from v0.3.3 to v2.2. The two-track approach allows parallel development of physics core (Track 1) and user interface (Track 2), with a 4-week timeline and clear validation criteria.

**Key Success Metrics**:
- ✅ Structure-preserving integrators with provable conservation
- ✅ Torsion as first-class variable driving physics
- ✅ LoD-gated dispatch with dynamic escalation
- ✅ Interactive scenario editor with event logging
- ✅ All performance targets met (<220 ns/cell Clebsch, 60 FPS UI)
- ✅ Full backward compatibility with v0.3.3 SAB layout
- ✅ Cross-platform determinism maintained

**Next Actions**:
1. Review and approve this plan
2. Create progress tracking documents
3. Set up directory structure
4. Assign teams to Track 1 and Track 2
5. Begin Week 1 implementation (Torsion + RKMK4)

---

**Document Control**

- **Version**: 1.0
- **Status**: Planning Phase
- **Approval Required**: Technical Lead, Physics Team Lead, Visualization Team Lead
- **Target Start Date**: Week of 2025-11-18
- **Target Completion**: 2025-12-16

---
