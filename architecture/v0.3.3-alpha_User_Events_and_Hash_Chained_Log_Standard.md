# v0.3.3-alpha User Events and Hash-Chained Log Standard

**Version:** v0.3.3-alpha
**Status:** Production Ready
**Last Updated:** 2025-11-16

## Purpose

This document defines the standard for auditable, replayable user interactions in negentropic-core. It specifies the canonical JSON serialization format (enforced field order), timestamp resolution, and the precise structure of the SHA-256 hash chain for the event log.

---

## 1. Overview

### 1.1 Motivation

**Requirements:**
1. **Auditability:** Every user action must be permanently logged
2. **Replayability:** Entire simulation can be reconstructed from event log + seed
3. **Tamper-Evidence:** Modification of any event invalidates hash chain
4. **Determinism:** Same events + seed → identical final state

**Use Cases:**
- Scientific reproducibility (publish event log with paper)
- Debugging (replay to failure point)
- Competitive gameplay (verify scores)
- Regulatory compliance (land management decisions)

### 1.2 Design Principles

1. **Append-Only:** Events never deleted or modified
2. **Cryptographically Linked:** Each event hashes previous event
3. **Canonical Serialization:** Field order deterministic (no JSON key reordering)
4. **Timestamp Resolution:** Microsecond precision (±1 µs)
5. **Version Tagging:** Schema version in every event

---

## 2. Event Schema

### 2.1 Base Event Structure

**JSON Format:**

```json
{
  "event_id": 12345,
  "timestamp_us": 1700000000000000,
  "event_type": "place_intervention",
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "user_id": "user@example.com",
  "schema_version": 1,
  "prev_hash": "a1b2c3d4e5f6...",
  "payload": { ... },
  "hash": "f6e5d4c3b2a1..."
}
```

**Field Descriptions:**

| Field | Type | Description |
|-------|------|-------------|
| `event_id` | uint64 | Monotonic counter (0, 1, 2, ...) |
| `timestamp_us` | uint64 | Unix epoch microseconds |
| `event_type` | string | Event category (see Section 2.2) |
| `session_id` | UUID | Unique session identifier |
| `user_id` | string | User identifier (email, UUID, etc.) |
| `schema_version` | uint32 | Event schema version (current: 1) |
| `prev_hash` | string (hex) | SHA-256 hash of previous event |
| `payload` | object | Event-specific data (see Section 2.3) |
| `hash` | string (hex) | SHA-256 hash of this event (excluding `hash` field) |

### 2.2 Event Types

**Enumeration:**

```c
typedef enum {
    EVENT_SESSION_START = 0,
    EVENT_SESSION_END = 1,
    EVENT_PLACE_INTERVENTION = 2,
    EVENT_REMOVE_INTERVENTION = 3,
    EVENT_CHANGE_PARAMETER = 4,
    EVENT_CAMERA_MOVE = 5,
    EVENT_SIMULATION_STEP = 6,
    EVENT_CHECKPOINT = 7
} EventType;
```

**String Mapping:**

```c
const char* EVENT_TYPE_STRINGS[] = {
    "session_start",
    "session_end",
    "place_intervention",
    "remove_intervention",
    "change_parameter",
    "camera_move",
    "simulation_step",
    "checkpoint"
};
```

### 2.3 Payload Specifications

**2.3.1 `session_start`**

```json
{
  "rng_seed": 123456789,
  "initial_state_hash": "a1b2c3...",
  "version": "v0.3.3-alpha",
  "platform": "web-wasm",
  "grid_size": [100, 100],
  "scenario": "LoessPlateau"
}
```

**2.3.2 `place_intervention`**

```json
{
  "intervention_type": "gravel_mulch",
  "position": [123, 456],
  "radius": 10,
  "parameters": {
    "depth_mm": 50,
    "coverage": 0.8
  }
}
```

**2.3.3 `change_parameter`**

```json
{
  "parameter_path": "hydrology.K_sat",
  "old_value": 0.0036,
  "new_value": 0.0050
}
```

**2.3.4 `simulation_step`**

```json
{
  "step_number": 12345,
  "dt_seconds": 3600.0,
  "state_hash": "f6e5d4...",
  "error_flags": {
    "overflow_errors": 0,
    "nan_detected": 0,
    "so3_drift": 2
  }
}
```

**2.3.5 `checkpoint`**

```json
{
  "state_size_bytes": 1048576,
  "state_hash": "a1b2c3...",
  "compression": "lz4",
  "compressed_size_bytes": 524288,
  "storage_url": "s3://bucket/checkpoints/12345.bin"
}
```

---

## 3. Canonical JSON Serialization

### 3.1 Field Ordering

**CRITICAL:** JSON keys must appear in deterministic order (alphabetical).

**Enforced Order (Base Event):**

```
1. event_id
2. event_type
3. hash
4. payload
5. prev_hash
6. schema_version
7. session_id
8. timestamp_us
9. user_id
```

**Implementation:**

```c
// Use JSON-C library with sorted object keys
json_object* create_event_json(Event* event) {
    json_object* obj = json_object_new_object();

    // Insert in alphabetical order (JSON-C maintains insertion order)
    json_object_object_add(obj, "event_id", json_object_new_int64(event->event_id));
    json_object_object_add(obj, "event_type", json_object_new_string(EVENT_TYPE_STRINGS[event->event_type]));
    json_object_object_add(obj, "hash", json_object_new_string(event->hash));
    json_object_object_add(obj, "payload", create_payload_json(event->payload));
    json_object_object_add(obj, "prev_hash", json_object_new_string(event->prev_hash));
    json_object_object_add(obj, "schema_version", json_object_new_int(event->schema_version));
    json_object_object_add(obj, "session_id", json_object_new_string(event->session_id));
    json_object_object_add(obj, "timestamp_us", json_object_new_int64(event->timestamp_us));
    json_object_object_add(obj, "user_id", json_object_new_string(event->user_id));

    return obj;
}
```

### 3.2 Numeric Precision

**Integers:** Exact representation (no decimals)
**Floats:** 6 decimal places (sufficient for physical parameters)

```c
// Bad: "value": 0.003599999  (floating-point noise)
// Good: "value": 0.0036      (rounded to 6 decimals)

char* format_float(float value) {
    static char buffer[64];
    snprintf(buffer, sizeof(buffer), "%.6f", value);
    return buffer;
}
```

### 3.3 Whitespace Handling

**Canonical Format:** Compact (no extra whitespace)

```json
{"event_id":123,"event_type":"session_start","payload":{...}}
```

**NOT:**

```json
{
  "event_id": 123,
  "event_type": "session_start",
  "payload": {
    ...
  }
}
```

**Implementation:**

```c
// JSON-C compact format
const char* json_str = json_object_to_json_string_ext(obj, JSON_C_TO_STRING_PLAIN);
```

---

## 4. SHA-256 Hash Chain

### 4.1 Hash Computation

**Input:** JSON string (excluding `hash` field)

**Algorithm:**

```c
#include <openssl/sha.h>

void compute_event_hash(Event* event) {
    // 1. Serialize to JSON (without hash field)
    json_object* obj = create_event_json_without_hash(event);
    const char* json_str = json_object_to_json_string_ext(obj, JSON_C_TO_STRING_PLAIN);

    // 2. Compute SHA-256
    unsigned char hash_bytes[SHA256_DIGEST_LENGTH];
    SHA256((unsigned char*)json_str, strlen(json_str), hash_bytes);

    // 3. Convert to hex string
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(&event->hash[i * 2], "%02x", hash_bytes[i]);
    }
    event->hash[64] = '\0';  // Null-terminate

    json_object_put(obj);
}
```

### 4.2 Chain Validation

**Genesis Event:**

```json
{
  "event_id": 0,
  "event_type": "session_start",
  "prev_hash": "0000000000000000000000000000000000000000000000000000000000000000",
  ...
}
```

**Subsequent Events:**

```json
{
  "event_id": 1,
  "prev_hash": "a1b2c3d4e5f6...",  // Hash of event_id=0
  ...
}
```

**Validation Function:**

```c
bool validate_event_chain(Event* events, uint32_t num_events) {
    for (uint32_t i = 1; i < num_events; i++) {
        Event* prev = &events[i - 1];
        Event* curr = &events[i];

        // Check prev_hash matches
        if (strcmp(curr->prev_hash, prev->hash) != 0) {
            fprintf(stderr, "Hash chain broken at event %u\n", i);
            return false;
        }

        // Recompute hash and verify
        char recomputed_hash[65];
        compute_event_hash_into(curr, recomputed_hash);
        if (strcmp(curr->hash, recomputed_hash) != 0) {
            fprintf(stderr, "Event %u hash mismatch\n", i);
            return false;
        }
    }
    return true;
}
```

### 4.3 Tamper Detection

**Scenario:** Attacker modifies event payload.

**Result:** Hash mismatch → chain invalidation

**Example:**

```
Original Event 5: hash = "a1b2c3..."
Modified Event 5: payload changed → new hash = "d4e5f6..."
Event 6: prev_hash = "a1b2c3..." (doesn't match modified hash)
→ Validation fails at Event 6
```

---

## 5. Timestamp Resolution

### 5.1 Microsecond Precision

**Format:** Unix epoch microseconds (uint64)

**Range:** 1970-01-01 00:00:00 UTC to 2262-04-11 23:47:16 UTC

**Precision:** ±1 µs (sufficient for 10 Hz simulation)

### 5.2 Implementation

**C (Linux):**

```c
#include <sys/time.h>

uint64_t get_timestamp_us() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return (uint64_t)tv.tv_sec * 1000000ULL + (uint64_t)tv.tv_usec;
}
```

**JavaScript:**

```javascript
function getTimestampUs() {
    return BigInt(Math.floor(performance.timeOrigin + performance.now()) * 1000);
}
```

### 5.3 Monotonicity Guarantee

**Requirement:** `timestamp_us[i+1] > timestamp_us[i]`

**Enforcement:**

```c
static uint64_t last_timestamp = 0;

uint64_t get_monotonic_timestamp_us() {
    uint64_t ts = get_timestamp_us();

    // If clock goes backward (NTP adjustment), increment by 1
    if (ts <= last_timestamp) {
        ts = last_timestamp + 1;
    }

    last_timestamp = ts;
    return ts;
}
```

---

## 6. Event Log Storage

### 6.1 File Format

**Newline-Delimited JSON (NDJSON):**

```
{"event_id":0,"event_type":"session_start",...}
{"event_id":1,"event_type":"place_intervention",...}
{"event_id":2,"event_type":"simulation_step",...}
```

**Advantages:**
- Streamable (parse one event at a time)
- Append-friendly (no array wrapper)
- Grep-able (each line is self-contained)

### 6.2 Append API

```c
void append_event_to_log(const char* log_path, Event* event) {
    FILE* fp = fopen(log_path, "a");  // Append mode
    if (!fp) {
        perror("Failed to open log");
        return;
    }

    // Compute hash
    compute_event_hash(event);

    // Serialize to JSON
    json_object* obj = create_event_json(event);
    const char* json_str = json_object_to_json_string_ext(obj, JSON_C_TO_STRING_PLAIN);

    // Write to file
    fprintf(fp, "%s\n", json_str);
    fflush(fp);  // Immediate flush (crash-safe)

    fclose(fp);
    json_object_put(obj);
}
```

### 6.3 Compression (Optional)

**LZ4 Compression:** ~3-5× reduction for repetitive events

```c
#include <lz4.h>

void compress_event_log(const char* input_path, const char* output_path) {
    // Read entire log
    FILE* in = fopen(input_path, "rb");
    fseek(in, 0, SEEK_END);
    size_t in_size = ftell(in);
    rewind(in);

    char* in_data = malloc(in_size);
    fread(in_data, 1, in_size, in);
    fclose(in);

    // Compress
    int max_compressed_size = LZ4_compressBound(in_size);
    char* compressed = malloc(max_compressed_size);
    int compressed_size = LZ4_compress_default(in_data, compressed, in_size, max_compressed_size);

    // Write compressed
    FILE* out = fopen(output_path, "wb");
    fwrite(&in_size, sizeof(size_t), 1, out);  // Store original size
    fwrite(compressed, 1, compressed_size, out);
    fclose(out);

    free(in_data);
    free(compressed);
}
```

---

## 7. Replay Protocol

### 7.1 Deterministic Replay

**Steps:**
1. Load event log
2. Initialize simulation with `session_start` event (extract seed)
3. Replay events in order:
   - Apply interventions
   - Step simulation (verify `state_hash` matches)
4. Final state hash must match last `checkpoint` event

**Implementation:**

```c
bool replay_event_log(const char* log_path) {
    FILE* fp = fopen(log_path, "r");
    if (!fp) return false;

    SimulationState* sim = NULL;
    char line[8192];

    while (fgets(line, sizeof(line), fp)) {
        json_object* obj = json_tokener_parse(line);
        Event event;
        parse_event_from_json(obj, &event);

        switch (event.event_type) {
            case EVENT_SESSION_START:
                sim = create_simulation_from_event(&event);
                break;

            case EVENT_PLACE_INTERVENTION:
                apply_intervention(sim, &event);
                break;

            case EVENT_SIMULATION_STEP:
                neg_step(sim, event.payload.dt_seconds);

                // Verify state hash
                uint64_t actual_hash = neg_get_state_hash(sim);
                uint64_t expected_hash = parse_hash(event.payload.state_hash);
                if (actual_hash != expected_hash) {
                    fprintf(stderr, "State hash mismatch at step %llu\n", event.event_id);
                    return false;
                }
                break;

            // ... other event types
        }

        json_object_put(obj);
    }

    fclose(fp);
    neg_destroy(sim);
    return true;
}
```

### 7.2 Partial Replay (Checkpointing)

**Use Case:** Replay from checkpoint instead of start (faster)

**Protocol:**
1. Find latest `checkpoint` event before target step
2. Load checkpoint binary state
3. Replay events from checkpoint to target

**Implementation:**

```c
bool replay_from_checkpoint(const char* log_path, uint64_t target_step) {
    // 1. Find checkpoint before target
    Event* checkpoint = find_latest_checkpoint_before(log_path, target_step);
    if (!checkpoint) {
        return replay_event_log(log_path);  // No checkpoint, full replay
    }

    // 2. Load checkpoint state
    SimulationState* sim = load_checkpoint_from_url(checkpoint->payload.storage_url);

    // 3. Replay events from checkpoint to target
    replay_events_from(log_path, checkpoint->event_id + 1, target_step, sim);

    neg_destroy(sim);
    return true;
}
```

---

## 8. Security Considerations

### 8.1 Hash Collision Resistance

**SHA-256:** 2^128 operations for collision (~10^38 years at 1 EH/s)

**Acceptable for:**
- Scientific reproducibility
- Casual tamper detection

**NOT sufficient for:**
- Financial transactions
- Cryptographic signatures (use HMAC or EdDSA)

### 8.2 Digital Signatures (Optional)

**Use Case:** Verify event log authenticity (not just integrity)

**Protocol:** Sign entire log with private key

```c
#include <openssl/rsa.h>
#include <openssl/pem.h>

void sign_event_log(const char* log_path, const char* private_key_path, const char* signature_path) {
    // Load private key
    FILE* key_file = fopen(private_key_path, "r");
    RSA* rsa = PEM_read_RSAPrivateKey(key_file, NULL, NULL, NULL);
    fclose(key_file);

    // Read log
    FILE* log = fopen(log_path, "rb");
    fseek(log, 0, SEEK_END);
    size_t log_size = ftell(log);
    rewind(log);
    unsigned char* log_data = malloc(log_size);
    fread(log_data, 1, log_size, log);
    fclose(log);

    // Hash log
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256(log_data, log_size, hash);

    // Sign hash
    unsigned char signature[256];
    unsigned int sig_len;
    RSA_sign(NID_sha256, hash, SHA256_DIGEST_LENGTH, signature, &sig_len, rsa);

    // Write signature
    FILE* sig_file = fopen(signature_path, "wb");
    fwrite(signature, 1, sig_len, sig_file);
    fclose(sig_file);

    RSA_free(rsa);
    free(log_data);
}
```

---

## 9. Performance Characteristics

### 9.1 Benchmarks

| Operation | Latency | Throughput |
|-----------|---------|------------|
| Compute SHA-256 (256 bytes) | ~1 µs | 1M hashes/sec |
| JSON serialization (event) | ~5 µs | 200k events/sec |
| Append to log (disk) | ~50 µs | 20k events/sec |
| Replay event (in-memory) | ~10 µs | 100k events/sec |

**Platform:** x86-64, GCC 11.4, SSD storage

### 9.2 Overhead

**Per Simulation Step:**
- Create `simulation_step` event: ~5 µs
- Compute hash: ~1 µs
- Append to log: ~50 µs
- **Total: ~56 µs** (<1% of 10 Hz frame budget)

---

## 10. Testing and Validation

### 10.1 Unit Tests

**Required Coverage:**
1. Canonical JSON serialization (field order)
2. SHA-256 hash computation
3. Hash chain validation
4. Timestamp monotonicity
5. Replay determinism

**Example Test:**

```c
void test_hash_chain() {
    Event events[3];

    // Genesis event
    events[0] = create_session_start_event();
    compute_event_hash(&events[0]);

    // Event 1
    events[1] = create_intervention_event();
    strcpy(events[1].prev_hash, events[0].hash);
    compute_event_hash(&events[1]);

    // Event 2
    events[2] = create_simulation_step_event();
    strcpy(events[2].prev_hash, events[1].hash);
    compute_event_hash(&events[2]);

    // Validate chain
    assert(validate_event_chain(events, 3));

    // Tamper with event 1
    events[1].payload.position[0] = 999;
    compute_event_hash(&events[1]);  // Recompute (changes hash)

    // Validation should fail
    assert(!validate_event_chain(events, 3));
}
```

### 10.2 Replay Validation

**Test:** Run simulation for 1000 steps, log all events, replay from log.

```c
void test_replay_determinism() {
    const char* log_path = "/tmp/test_replay.ndjson";

    // Original run
    SimulationState* sim1 = create_simulation_with_seed(123456789);
    for (int i = 0; i < 1000; i++) {
        neg_step(sim1, 3600.0f);
        log_simulation_step_event(log_path, sim1, i);
    }
    uint64_t hash1 = neg_get_state_hash(sim1);
    neg_destroy(sim1);

    // Replay
    SimulationState* sim2 = replay_event_log(log_path);
    uint64_t hash2 = neg_get_state_hash(sim2);
    neg_destroy(sim2);

    // Hashes must match
    assert(hash1 == hash2);
}
```

---

## 11. References

1. **SHA-256:** FIPS PUB 180-4, "Secure Hash Standard" (2015)
2. **NDJSON:** Newline Delimited JSON Specification (http://ndjson.org)
3. **LZ4:** Collet, Y. "LZ4 - Extremely fast compression" (2020)
4. **Event Sourcing:** Fowler, M. "Event Sourcing" (2005)
5. **Blockchain Principles:** Nakamoto, S. "Bitcoin: A Peer-to-Peer Electronic Cash System" (2008)

---

**Document Control:**
- **Approved by:** Technical Lead
- **Review Frequency:** Every release
- **Next Review:** v0.4.0-alpha
