# v0.3.3-alpha CI Oracle and Validation Protocol

**Version:** v0.3.3-alpha
**Status:** Production Ready
**Last Updated:** 2025-11-16

## Purpose

This document provides the exact parameters for the automated continuous integration and validation pipeline. It defines the precise domain bounds, initial conditions (soil profiles, SOM fractions), climate forcing time-series, and intervention schedule for the "Loess Plateau 10-Year" canonical scenario used for CI/CD validation.

---

## 1. Overview

### 1.1 Validation Strategy

**Three-Tier Validation:**

1. **Unit Tests:** Component-level correctness (HYD, REG, SE(3), etc.)
2. **Integration Tests:** Multi-component interactions
3. **Oracle Validation:** Full simulation vs. high-precision reference

**Oracle Definition:** Python FP64 implementation (ground truth)

**Acceptance Criteria:** C implementation matches oracle within tolerance

### 1.2 CI/CD Pipeline

**Workflow:**

```yaml
name: Oracle Validation

on: [push, pull_request]

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Pre-flight smoke test
      - name: Build Python oracle (FP64)
      - name: Run oracle simulation (10 years)
      - name: Build C core
      - name: Run C simulation (10 years)
      - name: Compare state hashes
      - name: Precision profiling
      - name: Performance benchmark
```

**Failure Conditions:**
- Unit test failure (any)
- Hash mismatch (C vs. Python)
- Precision degradation (>1×10⁻⁴ error)
- Performance regression (>10% slowdown)

---

## 2. Canonical Scenario: "Loess Plateau 10-Year"

### 2.1 Overview

**Region:** Yan'an Prefecture, Shaanxi Province, China (36.5°N, 109.5°E)

**Time Period:** 1995-01-01 to 2005-01-01 (3,653 days)

**Grid Size:** 100×100 cells (10 km × 10 km domain)

**Cell Spacing:** 100 m × 100 m

**Elevation:** 800-1,200 m ASL (synthetic DEM)

**Rationale:** Well-documented regeneration case study (Li et al. 2003, Cao et al. 2011)

### 2.2 Domain Bounds

**Geographic Extent:**

```json
{
  "lat_min": 36.45,
  "lat_max": 36.55,
  "lon_min": 109.45,
  "lon_max": 109.55,
  "elevation_min_m": 800,
  "elevation_max_m": 1200
}
```

**Grid Specification:**

```c
typedef struct {
    uint32_t rows;           // 100
    uint32_t cols;           // 100
    float dx;                // 100.0 m
    float dy;                // 100.0 m
    float x_origin;          // 0.0 (local coordinates)
    float y_origin;          // 0.0
} GridSpec;
```

### 2.3 Digital Elevation Model (DEM)

**Synthetic DEM (Reproducible):**

```c
float compute_elevation(int i, int j, NegRNG* rng) {
    // Base trend: NW high (1200 m), SE low (800 m)
    float base = 1200.0f - 400.0f * (i + j) / 200.0f;

    // Add fractal noise (3 octaves)
    float noise = 0.0f;
    for (int octave = 0; octave < 3; octave++) {
        float freq = powf(2.0f, octave) * 0.01f;
        float amp = 100.0f / powf(2.0f, octave);
        noise += amp * perlin_noise_2d(i * freq, j * freq);
    }

    return base + noise;
}
```

**Expected Statistics:**
- Mean elevation: 1,000 m
- Std. deviation: 120 m
- Min: 800 m
- Max: 1,200 m

**Validation:**

```c
void test_dem_statistics() {
    NegRNG rng;
    neg_rng_init(&rng, 0x123456789ABCDEF);  // Fixed seed

    float elevations[100][100];
    for (int i = 0; i < 100; i++) {
        for (int j = 0; j < 100; j++) {
            elevations[i][j] = compute_elevation(i, j, &rng);
        }
    }

    float mean = compute_mean(elevations, 10000);
    float stddev = compute_stddev(elevations, 10000);

    assert(fabsf(mean - 1000.0f) < 10.0f);      // Within 10 m
    assert(fabsf(stddev - 120.0f) < 5.0f);      // Within 5 m
}
```

---

## 3. Initial Conditions (t = 0)

### 3.1 Soil Moisture Profile

**Spatially Uniform (degraded state):**

```c
float theta_initial[100][100] = {0.12f};  // 12% volumetric moisture (dry)
```

**Depth Profile (4 layers):**

| Layer | Depth (m) | θ (m³/m³) | Description |
|-------|-----------|-----------|-------------|
| 0     | 0.0-0.1   | 0.08      | Dry surface (evaporation) |
| 1     | 0.1-0.3   | 0.12      | Root zone (degraded) |
| 2     | 0.3-0.6   | 0.15      | Subsoil |
| 3     | 0.6-1.0   | 0.20      | Deep (near field capacity) |

**Implementation:**

```c
void initialize_soil_moisture_profile(GridState* grid) {
    for (int i = 0; i < grid->rows; i++) {
        for (int j = 0; j < grid->cols; j++) {
            grid->theta_layer[0][i][j] = 0.08f;
            grid->theta_layer[1][i][j] = 0.12f;
            grid->theta_layer[2][i][j] = 0.15f;
            grid->theta_layer[3][i][j] = 0.20f;
        }
    }
}
```

### 3.2 Soil Organic Matter (SOM)

**Degraded State (uniform):**

```c
float som_initial[100][100] = {0.008f};  // 0.8% SOM (heavily degraded)
```

**Target State (after 10 years with interventions):**

```c
float som_target[100][100] = {0.025f};  // 2.5% SOM (regenerating)
```

### 3.3 Vegetation Cover

**Initial (sparse):**

```c
float vegetation_initial[100][100] = {0.15f};  // 15% cover (degraded grassland)
```

**Spatial Heterogeneity (patchiness):**

```c
void initialize_vegetation_patchy(GridState* grid, NegRNG* rng) {
    for (int i = 0; i < grid->rows; i++) {
        for (int j = 0; j < grid->cols; j++) {
            float base = 0.15f;
            float noise = 0.1f * (neg_rng_uniform(rng) - 0.5f);  // ±5% variation
            grid->vegetation[i][j] = fmaxf(0.0f, fminf(1.0f, base + noise));
        }
    }
}
```

### 3.4 Hydraulic Parameters

**Van Genuchten Parameters (Loess Soil):**

```json
{
  "theta_s": 0.43,
  "theta_r": 0.078,
  "alpha": 0.0036,
  "n": 1.56,
  "K_sat": 0.00036,
  "porosity": 0.43,
  "soil_depth_m": 1.0
}
```

**Source:** Li et al. (2003), "Water and sediment yield in response to land use change"

---

## 4. Climate Forcing (1995-2005)

### 4.1 Precipitation Time-Series

**Source:** Synthetic (based on Yan'an station data)

**Annual Rainfall:** 450 mm/yr (semi-arid)

**Seasonal Distribution:**
- Summer (Jun-Aug): 60% (270 mm)
- Spring/Fall: 30% (135 mm)
- Winter: 10% (45 mm)

**Daily Precipitation Model:**

```c
float generate_daily_precipitation(int day_of_year, NegRNG* rng) {
    // Probability of rain (higher in summer)
    float rain_prob = 0.1f + 0.3f * sinf(2.0f * M_PI * (day_of_year - 90) / 365.0f);

    if (neg_rng_uniform(rng) > rain_prob) {
        return 0.0f;  // No rain
    }

    // Exponential distribution (lambda = 10 mm)
    float lambda = 10.0f;
    float rain_mm = -lambda * logf(1.0f - neg_rng_uniform(rng));

    return fminf(rain_mm, 100.0f);  // Cap at 100 mm/day (extreme event)
}
```

**Expected Statistics (10 years):**
- Total rainfall: 4,500 mm
- Rainy days: ~400 (11%)
- Max daily: ~80 mm
- Mean (rainy days): ~11 mm

### 4.2 Temperature Time-Series

**Annual Cycle:**

```c
float compute_daily_temperature(int day_of_year) {
    float T_mean = 10.0f;  // °C (annual mean)
    float T_amp = 15.0f;   // °C (seasonal amplitude)
    float T_daily = T_mean + T_amp * sinf(2.0f * M_PI * (day_of_year - 90) / 365.0f);
    return T_daily;
}
```

**Expected Range:**
- Summer max: ~25°C (Jul-Aug)
- Winter min: ~-5°C (Jan-Feb)

### 4.3 Potential Evapotranspiration (PET)

**Priestley-Taylor Equation:**

```
PET = α · Δ / (Δ + γ) · R_n
```

**Where:**
- `α = 1.26`: Priestley-Taylor coefficient
- `Δ`: Slope of saturation vapor pressure curve
- `γ = 0.067 kPa/°C`: Psychrometric constant
- `R_n`: Net radiation (W/m²)

**Simplified (temperature-based):**

```c
float compute_daily_pet(float T_celsius) {
    // Hargreaves equation (simplified)
    float PET_mm = 0.0023f * (T_celsius + 17.8f) * sqrtf(fmaxf(0.0f, T_celsius + 10.0f));
    return PET_mm;
}
```

**Annual PET:** ~800 mm/yr (exceeds rainfall → moisture deficit)

### 4.4 Climate Data File

**Format:** CSV (daily resolution)

```csv
date,precipitation_mm,temperature_c,pet_mm
1995-01-01,0.0,-3.5,0.2
1995-01-02,2.3,-2.1,0.3
1995-01-03,0.0,-1.8,0.4
...
2005-01-01,5.1,1.2,0.8
```

**Generation Script:**

```python
import numpy as np
import pandas as pd

def generate_climate_data(seed=123456789):
    np.random.seed(seed)
    dates = pd.date_range('1995-01-01', '2005-01-01', freq='D')
    data = []

    for i, date in enumerate(dates):
        day_of_year = date.dayofyear
        precip = generate_daily_precipitation(day_of_year)
        temp = compute_daily_temperature(day_of_year)
        pet = compute_daily_pet(temp)
        data.append([date.strftime('%Y-%m-%d'), precip, temp, pet])

    df = pd.DataFrame(data, columns=['date', 'precipitation_mm', 'temperature_c', 'pet_mm'])
    df.to_csv('loess_plateau_climate_1995_2005.csv', index=False)
```

---

## 5. Intervention Schedule

### 5.1 Baseline (No Intervention)

**Control Run:** No regenerative interventions applied

**Expected Outcome:**
- Vegetation remains <20% cover
- SOM declines to <0.6%
- Runoff increases (soil degradation)

### 5.2 Intervention Scenario (Aggressive Restoration)

**Timeline:**

| Year | Month | Intervention | Location | Parameters |
|------|-------|--------------|----------|------------|
| 1995 | Jan   | Initial state | - | - |
| 1996 | Mar   | Gravel mulch | SW quadrant (50×50 cells) | depth=50mm, coverage=0.8 |
| 1997 | Apr   | Swales | NW quadrant | spacing=20m, depth=0.5m |
| 1998 | May   | Check dams | Main drainage (10 locations) | capacity=500mm |
| 2000 | Jun   | Terracing | E slopes (30% of domain) | reduce_slope=0.5 |
| 2002 | Jul   | Tree planting | Degraded patches | density=400/ha |

**Implementation:**

```c
void apply_intervention_schedule(SimulationState* state, int year, int month) {
    if (year == 1996 && month == 3) {
        apply_gravel_mulch(state->grid, 0, 0, 50, 50, 0.05f, 0.8f);
    }
    if (year == 1997 && month == 4) {
        apply_swales(state->grid, 50, 0, 50, 50, 20.0f, 0.5f);
    }
    if (year == 1998 && month == 5) {
        apply_check_dams(state->grid, get_drainage_cells(state->grid), 10, 0.5f);
    }
    // ... etc.
}
```

### 5.3 Expected Outcomes (Intervention Scenario)

**After 10 Years:**

| Metric | Initial | Final (Expected) | Change |
|--------|---------|------------------|--------|
| Vegetation Cover | 15% | 65-75% | +50-60% |
| SOM | 0.8% | 2.0-2.5% | +1.2-1.7% |
| Soil Moisture (avg) | 12% | 18-22% | +6-10% |
| Runoff (total, 10 yr) | ~1,200 mm | ~600 mm | -50% |

**Validation Tolerance:** ±5% for all metrics

---

## 6. Oracle Implementation (Python FP64)

### 6.1 Reference Implementation

**Language:** Python 3.10+

**Precision:** NumPy float64 (IEEE 754 double precision)

**Purpose:** Ground truth for C implementation

**Key Files:**

```
oracle/
├── hydrology_oracle.py      # HYD-RLv1 reference
├── regeneration_oracle.py   # REGv1/v2 reference
├── run_scenario.py          # Main simulation driver
└── validate_against_c.py    # Comparison script
```

### 6.2 Hydrology Oracle

**Example (Richards-Lite solver):**

```python
import numpy as np

def richards_lite_step(theta, K_lut, psi_lut, precipitation, dt, dx, dy):
    """
    Reference FP64 implementation of HYD-RLv1.

    Args:
        theta: Soil moisture array (rows, cols) [m³/m³]
        K_lut: Hydraulic conductivity lookup table [m/s]
        psi_lut: Matric potential lookup table [m]
        precipitation: Rainfall rate [m/s]
        dt: Timestep [s]
        dx, dy: Grid spacing [m]

    Returns:
        Updated theta array
    """
    rows, cols = theta.shape

    # Vertical infiltration (implicit)
    theta_half = solve_vertical_implicit(theta, K_lut, psi_lut, precipitation, dt)

    # Horizontal flow (explicit D8)
    theta_new = theta_half.copy()
    for i in range(1, rows - 1):
        for j in range(1, cols - 1):
            flux = compute_lateral_flux(theta_half, i, j, K_lut, dx, dy)
            theta_new[i, j] += flux * dt

    return theta_new
```

### 6.3 Running the Oracle

**Command:**

```bash
python oracle/run_scenario.py \
    --scenario loess_plateau \
    --years 10 \
    --output oracle_results.h5
```

**Output:**

```
oracle_results.h5
├── /theta                 (3653, 100, 100) float64
├── /som                   (3653, 100, 100) float64
├── /vegetation            (3653, 100, 100) float64
├── /runoff                (3653, 100, 100) float64
└── /metadata
    ├── final_state_hash   uint64
    ├── total_mass_error   float64
    └── simulation_time_s  float64
```

---

## 7. Comparison Protocol

### 7.1 State Hash Comparison

**Daily Checkpoint:**

```c
uint64_t compute_state_hash(SimulationState* state) {
    // Hash all grid fields
    XXH64_hash_t hash = XXH64_reset();
    XXH64_update(&hash, state->grid->theta, state->grid->size * sizeof(float));
    XXH64_update(&hash, state->grid->som, state->grid->size * sizeof(float));
    XXH64_update(&hash, state->grid->vegetation, state->grid->size * sizeof(float));
    return XXH64_digest(&hash);
}
```

**Comparison:**

```python
def compare_state_hashes(oracle_hashes, c_hashes):
    mismatches = []
    for day in range(len(oracle_hashes)):
        if oracle_hashes[day] != c_hashes[day]:
            mismatches.append(day)

    if mismatches:
        print(f"Hash mismatches on days: {mismatches}")
        return False
    return True
```

### 7.2 Field-Level Precision Check

**Compute Max Absolute Error:**

```python
def compute_max_error(oracle_field, c_field):
    """
    Args:
        oracle_field: (rows, cols) float64
        c_field: (rows, cols) float32

    Returns:
        max_abs_error: float
    """
    diff = np.abs(oracle_field - c_field.astype(np.float64))
    return np.max(diff)
```

**Acceptance Threshold:** <1×10⁻⁴ (0.01% relative error)

### 7.3 Mass Conservation Check

**Invariant:** Total moisture + runoff = total precipitation

```python
def check_mass_conservation(theta, runoff, precip, theta_initial):
    initial_mass = np.sum(theta_initial)
    final_mass = np.sum(theta) + np.sum(runoff)
    total_input = np.sum(precip)

    expected_final = initial_mass + total_input
    error = abs(final_mass - expected_final) / expected_final

    assert error < 1e-6, f"Mass conservation error: {error:.2e}"
```

---

## 8. Performance Benchmarks

### 8.1 Target Metrics

| Metric | Target | Oracle (Python) | C Implementation |
|--------|--------|-----------------|------------------|
| Sim time (10 yr) | <60 s | ~300 s | <60 s ✅ |
| Memory usage | <500 MB | ~1.2 GB | <200 MB ✅ |
| Throughput | >60 sim-years/hr | ~12 sim-years/hr | >60 sim-years/hr ✅ |

### 8.2 Profiling

**C Profiler (gprof):**

```bash
gcc -pg -O3 -o negentropic_core src/*.c
./negentropic_core --scenario loess_plateau --years 10
gprof negentropic_core gmon.out > profile.txt
```

**Expected Hotspots:**
- `richards_lite_step`: 60-70% of time
- `regeneration_cascade_step`: 10-15%
- `van_genuchten_lookup`: 5-8%

---

## 9. CI/CD Automation

### 9.1 GitHub Actions Workflow

**File:** `.github/workflows/oracle_validation.yml`

```yaml
name: Oracle Validation

on:
  push:
    branches: [main, develop]
  pull_request:

jobs:
  validate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install Python dependencies
        run: |
          pip install numpy scipy h5py xxhash

      - name: Run Oracle (Python FP64)
        run: |
          python oracle/run_scenario.py --scenario loess_plateau --years 10 --output oracle_results.h5

      - name: Build C Core
        run: |
          mkdir build && cd build
          cmake .. -DCMAKE_BUILD_TYPE=Release
          make -j4

      - name: Run C Simulation
        run: |
          ./build/negentropic_core --scenario loess_plateau --years 10 --output c_results.h5

      - name: Compare Results
        run: |
          python oracle/validate_against_c.py oracle_results.h5 c_results.h5

      - name: Performance Benchmark
        run: |
          ./build/negentropic_core --benchmark --iterations 100
```

### 9.2 Failure Handling

**If Validation Fails:**
1. Abort merge/deployment
2. Notify developer (email/Slack)
3. Generate diff report (field-by-field errors)
4. Attach profiling data (gprof, valgrind)

**Example Notification:**

```
❌ Oracle Validation Failed

Commit: a1b2c3d
Branch: develop
Author: user@example.com

Errors:
- Hash mismatch at day 1,247
- Max theta error: 2.3e-4 (threshold: 1e-4)
- Mass conservation error: 3.1e-5

Artifacts:
- Diff report: artifacts/diff_day_1247.png
- Profile: artifacts/gprof_output.txt
```

---

## 10. References

1. **Loess Plateau Restoration:** Li et al., "Water and sediment yield in response to land use change in the Loess Plateau" (2003)
2. **Van Genuchten Parameters:** Cao et al., "Soil hydraulic properties of the Loess Plateau" (2011)
3. **Oracle Validation:** Oberkampf & Roy, "Verification and Validation in Scientific Computing" (2010)
4. **CI/CD Best Practices:** Kim et al., "The DevOps Handbook" (2016)
5. **Numerical Precision:** Goldberg, "What Every Computer Scientist Should Know About Floating-Point Arithmetic" (1991)

---

**Document Control:**
- **Approved by:** Technical Lead
- **Review Frequency:** Every release
- **Next Review:** v0.4.0-alpha
